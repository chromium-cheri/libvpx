{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "509ec077_9c27d76d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-04T14:24:17Z",
      "side": 1,
      "message": "PS 2 should make the code formatting bot happy.",
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ec9b624_87ae1c0d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-04T18:41:43Z",
      "side": 1,
      "message": "Thanks for the patch Jonathan.\n\nThis passes test vectors locally. It could be extended for use in vpx_dsp/arm/vpx_scaled_convolve8_neon.c, but that is a less common configuration. A high-bitdepth variant would be another area that could be followed up with.",
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8de13bac_a30e572c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-05T14:55:06Z",
      "side": 1,
      "message": "A high-bitdepth implementation would not be possible using the Armv8.4-A dot product instructions as they only accept 8-bit operands. (It was tricky to make things fit with standard bitdepth - requiring a 128 * filter fudge factor.) The best hope for high-bitdepth is to use the new dot product instructions coming in Armv8.6-A and Armv9-A.\n\nImplementing the scaled-convolution function could be done in a subsequent patch. Could you help me understand when the different variants get used? There\u0027s this standard covolution, the averaging variant and the scaling one?",
      "parentUuid": "8ec9b624_87ae1c0d",
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "265594b6_4c35e6a3",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-04T18:41:43Z",
      "side": 1,
      "message": "just out of curiosity, is there a benefit to aligning beyond 8/16 on this platform?",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 18
      },
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "14f155c9_095f849d",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-05T14:55:06Z",
      "side": 1,
      "message": "Changed to 16 byte alignment. (This was a hangover from a previous implementation internal to me ;))\n\nThe only benefit of going above 16-byte alignment here would come from 64-byte alignment which would prevent this buffer from crossing a cache line... but given we\u0027re not loading this frequently enough for that to be a problem, let\u0027s stick with 16.",
      "parentUuid": "265594b6_4c35e6a3",
      "range": {
        "startLine": 58,
        "startChar": 16,
        "endLine": 58,
        "endChar": 18
      },
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7fb2edd6_31ec55f0",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 106,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-04T18:41:43Z",
      "side": 1,
      "message": "in the end the lanes are extracted anyway, but to your point about sticking with d registers when possible is there any difference if we change this to 4 shifts?",
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "74596eac_eacb005b",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 106,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-05T14:55:06Z",
      "side": 1,
      "message": "So the point was more to do with not moving to Q-registers when it\u0027s cost-inefficient[1] - i.e. combining things only to split them apart again after a single operation. There\u0027s no cost penalty here to do the combine as the instructions backing vqmovn can write to the top or bottom half of a Q-register. Additionally, the narrowing right shift instruction only takes Q-register inputs so keeping these separate would require an explicit, less useful combine with a zero-register. \n\nThere\u0027s no benefit from changing this to four shifts because it would make the subsequent store rather tricky - you\u0027d need extra unzip instructions to get things in the right place as the vqmovn and vqrshrun both narrow the element width.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/libvpx/source/libvpx/vpx_dsp/arm/vpx_convolve8_neon.c;l\u003d927",
      "parentUuid": "7fb2edd6_31ec55f0",
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32252c27_58623462",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-04T18:41:43Z",
      "side": 1,
      "message": "Availability these of xN intrinsics is mixed, I think x2 then x4 and later x3 was added. So this will fail with gcc-8. The builders have 8.3.0 so to add coverage for this configuration we\u0027d need an adapter or to do the 3 loads. In practice in other projects the compiler was doing the right thing with 3, but for convenience the adapter would be better. Can you add something to vpx_dsp/arm/mem_neon.h or for this?",
      "range": {
        "startLine": 122,
        "startChar": 37,
        "endLine": 122,
        "endChar": 48
      },
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e6c6e335_ed547c8c",
        "filename": "vpx_dsp/arm/vpx_convolve8_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-05T14:55:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "32252c27_58623462",
      "range": {
        "startLine": 122,
        "startChar": 37,
        "endLine": 122,
        "endChar": 48
      },
      "revId": "8838f24e837c7280573891b66ce8e2d26006c946",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}