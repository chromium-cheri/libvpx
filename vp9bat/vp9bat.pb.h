// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vp9bat.proto

#ifndef PROTOBUF_vp9bat_2eproto__INCLUDED
#define PROTOBUF_vp9bat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vp9bat_2eproto();
void protobuf_AssignDesc_vp9bat_2eproto();
void protobuf_ShutdownFile_vp9bat_2eproto();

class Point;
class VP9Syntax;
class VP9Syntax_SyntaxElement;
class LoopFilterEdge;
class SampleBlock;
class StreamInfo;
class Thumbnail;
class PictureInfo;
class PictureInfo_SegmentData;
class PictureInfo_Stat;
class PictureInfo_Stat_StatEntry;
class PictureInfo_NumericTree;
class PictureImgs;
class BlockInfo;
class BlockInfo_MV;
class BlockInfo_MV_MVPredictor;
class Coeffs;
class SuperblockInfo;
class SuperblockRegion;
class RawBytes;

enum LoopFilterEdge_FilterType {
  LoopFilterEdge_FilterType_LF_16WIDE = 0,
  LoopFilterEdge_FilterType_LF_8WIDE = 1,
  LoopFilterEdge_FilterType_LF_4WIDE = 2,
  LoopFilterEdge_FilterType_LF_2WIDE = 3
};
bool LoopFilterEdge_FilterType_IsValid(int value);
const LoopFilterEdge_FilterType LoopFilterEdge_FilterType_FilterType_MIN = LoopFilterEdge_FilterType_LF_16WIDE;
const LoopFilterEdge_FilterType LoopFilterEdge_FilterType_FilterType_MAX = LoopFilterEdge_FilterType_LF_2WIDE;
const int LoopFilterEdge_FilterType_FilterType_ARRAYSIZE = LoopFilterEdge_FilterType_FilterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoopFilterEdge_FilterType_descriptor();
inline const ::std::string& LoopFilterEdge_FilterType_Name(LoopFilterEdge_FilterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoopFilterEdge_FilterType_descriptor(), value);
}
inline bool LoopFilterEdge_FilterType_Parse(
    const ::std::string& name, LoopFilterEdge_FilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoopFilterEdge_FilterType>(
    LoopFilterEdge_FilterType_descriptor(), name, value);
}
enum BlockInfo_TxSize {
  BlockInfo_TxSize_TX_4X4 = 0,
  BlockInfo_TxSize_TX_8X8 = 1,
  BlockInfo_TxSize_TX_16X16 = 2,
  BlockInfo_TxSize_TX_32X32 = 3
};
bool BlockInfo_TxSize_IsValid(int value);
const BlockInfo_TxSize BlockInfo_TxSize_TxSize_MIN = BlockInfo_TxSize_TX_4X4;
const BlockInfo_TxSize BlockInfo_TxSize_TxSize_MAX = BlockInfo_TxSize_TX_32X32;
const int BlockInfo_TxSize_TxSize_ARRAYSIZE = BlockInfo_TxSize_TxSize_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockInfo_TxSize_descriptor();
inline const ::std::string& BlockInfo_TxSize_Name(BlockInfo_TxSize value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockInfo_TxSize_descriptor(), value);
}
inline bool BlockInfo_TxSize_Parse(
    const ::std::string& name, BlockInfo_TxSize* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockInfo_TxSize>(
    BlockInfo_TxSize_descriptor(), name, value);
}
enum BlockInfo_SwitchableFilterType {
  BlockInfo_SwitchableFilterType_MC_8TAP = 0,
  BlockInfo_SwitchableFilterType_MC_8TAP_SHARP = 1,
  BlockInfo_SwitchableFilterType_MC_8TAP_SMOOTH = 2
};
bool BlockInfo_SwitchableFilterType_IsValid(int value);
const BlockInfo_SwitchableFilterType BlockInfo_SwitchableFilterType_SwitchableFilterType_MIN = BlockInfo_SwitchableFilterType_MC_8TAP;
const BlockInfo_SwitchableFilterType BlockInfo_SwitchableFilterType_SwitchableFilterType_MAX = BlockInfo_SwitchableFilterType_MC_8TAP_SMOOTH;
const int BlockInfo_SwitchableFilterType_SwitchableFilterType_ARRAYSIZE = BlockInfo_SwitchableFilterType_SwitchableFilterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockInfo_SwitchableFilterType_descriptor();
inline const ::std::string& BlockInfo_SwitchableFilterType_Name(BlockInfo_SwitchableFilterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockInfo_SwitchableFilterType_descriptor(), value);
}
inline bool BlockInfo_SwitchableFilterType_Parse(
    const ::std::string& name, BlockInfo_SwitchableFilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockInfo_SwitchableFilterType>(
    BlockInfo_SwitchableFilterType_descriptor(), name, value);
}
enum BlockInfo_IntraMode {
  BlockInfo_IntraMode_DC_PRED = 0,
  BlockInfo_IntraMode_V_PRED = 1,
  BlockInfo_IntraMode_H_PRED = 2,
  BlockInfo_IntraMode_D45_PRED = 3,
  BlockInfo_IntraMode_D135_PRED = 4,
  BlockInfo_IntraMode_D117_PRED = 5,
  BlockInfo_IntraMode_D153_PRED = 6,
  BlockInfo_IntraMode_D207_PRED = 7,
  BlockInfo_IntraMode_D63_PRED = 8,
  BlockInfo_IntraMode_TM_PRED = 9
};
bool BlockInfo_IntraMode_IsValid(int value);
const BlockInfo_IntraMode BlockInfo_IntraMode_IntraMode_MIN = BlockInfo_IntraMode_DC_PRED;
const BlockInfo_IntraMode BlockInfo_IntraMode_IntraMode_MAX = BlockInfo_IntraMode_TM_PRED;
const int BlockInfo_IntraMode_IntraMode_ARRAYSIZE = BlockInfo_IntraMode_IntraMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockInfo_IntraMode_descriptor();
inline const ::std::string& BlockInfo_IntraMode_Name(BlockInfo_IntraMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockInfo_IntraMode_descriptor(), value);
}
inline bool BlockInfo_IntraMode_Parse(
    const ::std::string& name, BlockInfo_IntraMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockInfo_IntraMode>(
    BlockInfo_IntraMode_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class VP9Syntax_SyntaxElement : public ::google::protobuf::Message {
 public:
  VP9Syntax_SyntaxElement();
  virtual ~VP9Syntax_SyntaxElement();

  VP9Syntax_SyntaxElement(const VP9Syntax_SyntaxElement& from);

  inline VP9Syntax_SyntaxElement& operator=(const VP9Syntax_SyntaxElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VP9Syntax_SyntaxElement& default_instance();

  void Swap(VP9Syntax_SyntaxElement* other);

  // implements Message ----------------------------------------------

  VP9Syntax_SyntaxElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VP9Syntax_SyntaxElement& from);
  void MergeFrom(const VP9Syntax_SyntaxElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 intValue = 2;
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional string stringValue = 3;
  inline bool has_stringvalue() const;
  inline void clear_stringvalue();
  static const int kStringValueFieldNumber = 3;
  inline const ::std::string& stringvalue() const;
  inline void set_stringvalue(const ::std::string& value);
  inline void set_stringvalue(const char* value);
  inline void set_stringvalue(const char* value, size_t size);
  inline ::std::string* mutable_stringvalue();
  inline ::std::string* release_stringvalue();
  inline void set_allocated_stringvalue(::std::string* stringvalue);

  // optional int32 bcRange = 4;
  inline bool has_bcrange() const;
  inline void clear_bcrange();
  static const int kBcRangeFieldNumber = 4;
  inline ::google::protobuf::int32 bcrange() const;
  inline void set_bcrange(::google::protobuf::int32 value);

  // optional int32 bcValue = 5;
  inline bool has_bcvalue() const;
  inline void clear_bcvalue();
  static const int kBcValueFieldNumber = 5;
  inline ::google::protobuf::int32 bcvalue() const;
  inline void set_bcvalue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VP9Syntax.SyntaxElement)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_stringvalue();
  inline void clear_has_stringvalue();
  inline void set_has_bcrange();
  inline void clear_has_bcrange();
  inline void set_has_bcvalue();
  inline void clear_has_bcvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* stringvalue_;
  ::google::protobuf::int32 intvalue_;
  ::google::protobuf::int32 bcrange_;
  ::google::protobuf::int32 bcvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static VP9Syntax_SyntaxElement* default_instance_;
};
// -------------------------------------------------------------------

class VP9Syntax : public ::google::protobuf::Message {
 public:
  VP9Syntax();
  virtual ~VP9Syntax();

  VP9Syntax(const VP9Syntax& from);

  inline VP9Syntax& operator=(const VP9Syntax& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VP9Syntax& default_instance();

  void Swap(VP9Syntax* other);

  // implements Message ----------------------------------------------

  VP9Syntax* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VP9Syntax& from);
  void MergeFrom(const VP9Syntax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VP9Syntax_SyntaxElement SyntaxElement;

  // accessors -------------------------------------------------------

  // repeated .VP9Syntax.SyntaxElement elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::VP9Syntax_SyntaxElement& elements(int index) const;
  inline ::VP9Syntax_SyntaxElement* mutable_elements(int index);
  inline ::VP9Syntax_SyntaxElement* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::VP9Syntax_SyntaxElement >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::VP9Syntax_SyntaxElement >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:VP9Syntax)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::VP9Syntax_SyntaxElement > elements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static VP9Syntax* default_instance_;
};
// -------------------------------------------------------------------

class LoopFilterEdge : public ::google::protobuf::Message {
 public:
  LoopFilterEdge();
  virtual ~LoopFilterEdge();

  LoopFilterEdge(const LoopFilterEdge& from);

  inline LoopFilterEdge& operator=(const LoopFilterEdge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoopFilterEdge& default_instance();

  void Swap(LoopFilterEdge* other);

  // implements Message ----------------------------------------------

  LoopFilterEdge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoopFilterEdge& from);
  void MergeFrom(const LoopFilterEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoopFilterEdge_FilterType FilterType;
  static const FilterType LF_16WIDE = LoopFilterEdge_FilterType_LF_16WIDE;
  static const FilterType LF_8WIDE = LoopFilterEdge_FilterType_LF_8WIDE;
  static const FilterType LF_4WIDE = LoopFilterEdge_FilterType_LF_4WIDE;
  static const FilterType LF_2WIDE = LoopFilterEdge_FilterType_LF_2WIDE;
  static inline bool FilterType_IsValid(int value) {
    return LoopFilterEdge_FilterType_IsValid(value);
  }
  static const FilterType FilterType_MIN =
    LoopFilterEdge_FilterType_FilterType_MIN;
  static const FilterType FilterType_MAX =
    LoopFilterEdge_FilterType_FilterType_MAX;
  static const int FilterType_ARRAYSIZE =
    LoopFilterEdge_FilterType_FilterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FilterType_descriptor() {
    return LoopFilterEdge_FilterType_descriptor();
  }
  static inline const ::std::string& FilterType_Name(FilterType value) {
    return LoopFilterEdge_FilterType_Name(value);
  }
  static inline bool FilterType_Parse(const ::std::string& name,
      FilterType* value) {
    return LoopFilterEdge_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Point p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline const ::Point& p() const;
  inline ::Point* mutable_p();
  inline ::Point* release_p();
  inline void set_allocated_p(::Point* p);

  // required int32 component = 2;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 2;
  inline ::google::protobuf::int32 component() const;
  inline void set_component(::google::protobuf::int32 value);

  // required bool isVertical = 3;
  inline bool has_isvertical() const;
  inline void clear_isvertical();
  static const int kIsVerticalFieldNumber = 3;
  inline bool isvertical() const;
  inline void set_isvertical(bool value);

  // required .LoopFilterEdge.FilterType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::LoopFilterEdge_FilterType type() const;
  inline void set_type(::LoopFilterEdge_FilterType value);

  // required int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoopFilterEdge)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_component();
  inline void clear_has_component();
  inline void set_has_isvertical();
  inline void clear_has_isvertical();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Point* p_;
  ::google::protobuf::int32 component_;
  bool isvertical_;
  int type_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static LoopFilterEdge* default_instance_;
};
// -------------------------------------------------------------------

class SampleBlock : public ::google::protobuf::Message {
 public:
  SampleBlock();
  virtual ~SampleBlock();

  SampleBlock(const SampleBlock& from);

  inline SampleBlock& operator=(const SampleBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleBlock& default_instance();

  void Swap(SampleBlock* other);

  // implements Message ----------------------------------------------

  SampleBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SampleBlock& from);
  void MergeFrom(const SampleBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Point p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline const ::Point& p() const;
  inline ::Point* mutable_p();
  inline ::Point* release_p();
  inline void set_allocated_p(::Point* p);

  // required int32 w = 3;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 3;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 4;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 4;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // required bytes samples = 5;
  inline bool has_samples() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 5;
  inline const ::std::string& samples() const;
  inline void set_samples(const ::std::string& value);
  inline void set_samples(const char* value);
  inline void set_samples(const void* value, size_t size);
  inline ::std::string* mutable_samples();
  inline ::std::string* release_samples();
  inline void set_allocated_samples(::std::string* samples);

  // optional bytes flags = 6;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 6;
  inline const ::std::string& flags() const;
  inline void set_flags(const ::std::string& value);
  inline void set_flags(const char* value);
  inline void set_flags(const void* value, size_t size);
  inline ::std::string* mutable_flags();
  inline ::std::string* release_flags();
  inline void set_allocated_flags(::std::string* flags);

  // @@protoc_insertion_point(class_scope:SampleBlock)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_samples();
  inline void clear_has_samples();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Point* p_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::std::string* samples_;
  ::std::string* flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static SampleBlock* default_instance_;
};
// -------------------------------------------------------------------

class StreamInfo : public ::google::protobuf::Message {
 public:
  StreamInfo();
  virtual ~StreamInfo();

  StreamInfo(const StreamInfo& from);

  inline StreamInfo& operator=(const StreamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamInfo& default_instance();

  void Swap(StreamInfo* other);

  // implements Message ----------------------------------------------

  StreamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamInfo& from);
  void MergeFrom(const StreamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 numPics = 1;
  inline bool has_numpics() const;
  inline void clear_numpics();
  static const int kNumPicsFieldNumber = 1;
  inline ::google::protobuf::int32 numpics() const;
  inline void set_numpics(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:StreamInfo)
 private:
  inline void set_has_numpics();
  inline void clear_has_numpics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 numpics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static StreamInfo* default_instance_;
};
// -------------------------------------------------------------------

class Thumbnail : public ::google::protobuf::Message {
 public:
  Thumbnail();
  virtual ~Thumbnail();

  Thumbnail(const Thumbnail& from);

  inline Thumbnail& operator=(const Thumbnail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thumbnail& default_instance();

  void Swap(Thumbnail* other);

  // implements Message ----------------------------------------------

  Thumbnail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Thumbnail& from);
  void MergeFrom(const Thumbnail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 w = 1;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 1;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 2;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 2;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // required bytes thumbnail = 3;
  inline bool has_thumbnail() const;
  inline void clear_thumbnail();
  static const int kThumbnailFieldNumber = 3;
  inline const ::std::string& thumbnail() const;
  inline void set_thumbnail(const ::std::string& value);
  inline void set_thumbnail(const char* value);
  inline void set_thumbnail(const void* value, size_t size);
  inline ::std::string* mutable_thumbnail();
  inline ::std::string* release_thumbnail();
  inline void set_allocated_thumbnail(::std::string* thumbnail);

  // @@protoc_insertion_point(class_scope:Thumbnail)
 private:
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_thumbnail();
  inline void clear_has_thumbnail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::std::string* thumbnail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static Thumbnail* default_instance_;
};
// -------------------------------------------------------------------

class PictureInfo_SegmentData : public ::google::protobuf::Message {
 public:
  PictureInfo_SegmentData();
  virtual ~PictureInfo_SegmentData();

  PictureInfo_SegmentData(const PictureInfo_SegmentData& from);

  inline PictureInfo_SegmentData& operator=(const PictureInfo_SegmentData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureInfo_SegmentData& default_instance();

  void Swap(PictureInfo_SegmentData* other);

  // implements Message ----------------------------------------------

  PictureInfo_SegmentData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureInfo_SegmentData& from);
  void MergeFrom(const PictureInfo_SegmentData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool skip = 1;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 1;
  inline bool skip() const;
  inline void set_skip(bool value);

  // optional sint32 altQ = 2;
  inline bool has_altq() const;
  inline void clear_altq();
  static const int kAltQFieldNumber = 2;
  inline ::google::protobuf::int32 altq() const;
  inline void set_altq(::google::protobuf::int32 value);

  // optional sint32 altLF = 3;
  inline bool has_altlf() const;
  inline void clear_altlf();
  static const int kAltLFFieldNumber = 3;
  inline ::google::protobuf::int32 altlf() const;
  inline void set_altlf(::google::protobuf::int32 value);

  // optional int32 ref = 4;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 4;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PictureInfo.SegmentData)
 private:
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_altq();
  inline void clear_has_altq();
  inline void set_has_altlf();
  inline void clear_has_altlf();
  inline void set_has_ref();
  inline void clear_has_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool skip_;
  ::google::protobuf::int32 altq_;
  ::google::protobuf::int32 altlf_;
  ::google::protobuf::int32 ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureInfo_SegmentData* default_instance_;
};
// -------------------------------------------------------------------

class PictureInfo_Stat_StatEntry : public ::google::protobuf::Message {
 public:
  PictureInfo_Stat_StatEntry();
  virtual ~PictureInfo_Stat_StatEntry();

  PictureInfo_Stat_StatEntry(const PictureInfo_Stat_StatEntry& from);

  inline PictureInfo_Stat_StatEntry& operator=(const PictureInfo_Stat_StatEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureInfo_Stat_StatEntry& default_instance();

  void Swap(PictureInfo_Stat_StatEntry* other);

  // implements Message ----------------------------------------------

  PictureInfo_Stat_StatEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureInfo_Stat_StatEntry& from);
  void MergeFrom(const PictureInfo_Stat_StatEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PictureInfo.Stat.StatEntry)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureInfo_Stat_StatEntry* default_instance_;
};
// -------------------------------------------------------------------

class PictureInfo_Stat : public ::google::protobuf::Message {
 public:
  PictureInfo_Stat();
  virtual ~PictureInfo_Stat();

  PictureInfo_Stat(const PictureInfo_Stat& from);

  inline PictureInfo_Stat& operator=(const PictureInfo_Stat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureInfo_Stat& default_instance();

  void Swap(PictureInfo_Stat* other);

  // implements Message ----------------------------------------------

  PictureInfo_Stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureInfo_Stat& from);
  void MergeFrom(const PictureInfo_Stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PictureInfo_Stat_StatEntry StatEntry;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .PictureInfo.Stat.StatEntry rawEntries = 2;
  inline int rawentries_size() const;
  inline void clear_rawentries();
  static const int kRawEntriesFieldNumber = 2;
  inline const ::PictureInfo_Stat_StatEntry& rawentries(int index) const;
  inline ::PictureInfo_Stat_StatEntry* mutable_rawentries(int index);
  inline ::PictureInfo_Stat_StatEntry* add_rawentries();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
      rawentries() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
      mutable_rawentries();

  // repeated .PictureInfo.Stat.StatEntry areaNormalizedEntries = 3;
  inline int areanormalizedentries_size() const;
  inline void clear_areanormalizedentries();
  static const int kAreaNormalizedEntriesFieldNumber = 3;
  inline const ::PictureInfo_Stat_StatEntry& areanormalizedentries(int index) const;
  inline ::PictureInfo_Stat_StatEntry* mutable_areanormalizedentries(int index);
  inline ::PictureInfo_Stat_StatEntry* add_areanormalizedentries();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
      areanormalizedentries() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
      mutable_areanormalizedentries();

  // repeated .PictureInfo.Stat.StatEntry bitsNormalizedEntries = 4;
  inline int bitsnormalizedentries_size() const;
  inline void clear_bitsnormalizedentries();
  static const int kBitsNormalizedEntriesFieldNumber = 4;
  inline const ::PictureInfo_Stat_StatEntry& bitsnormalizedentries(int index) const;
  inline ::PictureInfo_Stat_StatEntry* mutable_bitsnormalizedentries(int index);
  inline ::PictureInfo_Stat_StatEntry* add_bitsnormalizedentries();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
      bitsnormalizedentries() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
      mutable_bitsnormalizedentries();

  // @@protoc_insertion_point(class_scope:PictureInfo.Stat)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry > rawentries_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry > areanormalizedentries_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry > bitsnormalizedentries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureInfo_Stat* default_instance_;
};
// -------------------------------------------------------------------

class PictureInfo_NumericTree : public ::google::protobuf::Message {
 public:
  PictureInfo_NumericTree();
  virtual ~PictureInfo_NumericTree();

  PictureInfo_NumericTree(const PictureInfo_NumericTree& from);

  inline PictureInfo_NumericTree& operator=(const PictureInfo_NumericTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureInfo_NumericTree& default_instance();

  void Swap(PictureInfo_NumericTree* other);

  // implements Message ----------------------------------------------

  PictureInfo_NumericTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureInfo_NumericTree& from);
  void MergeFrom(const PictureInfo_NumericTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 nodeValue = 1;
  inline bool has_nodevalue() const;
  inline void clear_nodevalue();
  static const int kNodeValueFieldNumber = 1;
  inline ::google::protobuf::int32 nodevalue() const;
  inline void set_nodevalue(::google::protobuf::int32 value);

  // optional string nodeName = 2;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 2;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // repeated .PictureInfo.NumericTree children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::PictureInfo_NumericTree& children(int index) const;
  inline ::PictureInfo_NumericTree* mutable_children(int index);
  inline ::PictureInfo_NumericTree* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_NumericTree >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_NumericTree >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:PictureInfo.NumericTree)
 private:
  inline void set_has_nodevalue();
  inline void clear_has_nodevalue();
  inline void set_has_nodename();
  inline void clear_has_nodename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nodename_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_NumericTree > children_;
  ::google::protobuf::int32 nodevalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureInfo_NumericTree* default_instance_;
};
// -------------------------------------------------------------------

class PictureInfo : public ::google::protobuf::Message {
 public:
  PictureInfo();
  virtual ~PictureInfo();

  PictureInfo(const PictureInfo& from);

  inline PictureInfo& operator=(const PictureInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureInfo& default_instance();

  void Swap(PictureInfo* other);

  // implements Message ----------------------------------------------

  PictureInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureInfo& from);
  void MergeFrom(const PictureInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PictureInfo_SegmentData SegmentData;
  typedef PictureInfo_Stat Stat;
  typedef PictureInfo_NumericTree NumericTree;

  // accessors -------------------------------------------------------

  // required int32 decodeIndex = 1;
  inline bool has_decodeindex() const;
  inline void clear_decodeindex();
  static const int kDecodeIndexFieldNumber = 1;
  inline ::google::protobuf::int32 decodeindex() const;
  inline void set_decodeindex(::google::protobuf::int32 value);

  // required int32 displayIndex = 2;
  inline bool has_displayindex() const;
  inline void clear_displayindex();
  static const int kDisplayIndexFieldNumber = 2;
  inline ::google::protobuf::int32 displayindex() const;
  inline void set_displayindex(::google::protobuf::int32 value);

  // required int32 w = 3;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 3;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 4;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 4;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // required bool isInter = 5;
  inline bool has_isinter() const;
  inline void clear_isinter();
  static const int kIsInterFieldNumber = 5;
  inline bool isinter() const;
  inline void set_isinter(bool value);

  // optional string digest = 6;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 6;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const char* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // repeated int32 references = 7;
  inline int references_size() const;
  inline void clear_references();
  static const int kReferencesFieldNumber = 7;
  inline ::google::protobuf::int32 references(int index) const;
  inline void set_references(int index, ::google::protobuf::int32 value);
  inline void add_references(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      references() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_references();

  // optional int32 lastRefIdx = 8;
  inline bool has_lastrefidx() const;
  inline void clear_lastrefidx();
  static const int kLastRefIdxFieldNumber = 8;
  inline ::google::protobuf::int32 lastrefidx() const;
  inline void set_lastrefidx(::google::protobuf::int32 value);

  // optional int32 goldRefIdx = 9;
  inline bool has_goldrefidx() const;
  inline void clear_goldrefidx();
  static const int kGoldRefIdxFieldNumber = 9;
  inline ::google::protobuf::int32 goldrefidx() const;
  inline void set_goldrefidx(::google::protobuf::int32 value);

  // optional int32 altRefIdx = 10;
  inline bool has_altrefidx() const;
  inline void clear_altrefidx();
  static const int kAltRefIdxFieldNumber = 10;
  inline ::google::protobuf::int32 altrefidx() const;
  inline void set_altrefidx(::google::protobuf::int32 value);

  // repeated .PictureInfo.SegmentData segmentData = 11;
  inline int segmentdata_size() const;
  inline void clear_segmentdata();
  static const int kSegmentDataFieldNumber = 11;
  inline const ::PictureInfo_SegmentData& segmentdata(int index) const;
  inline ::PictureInfo_SegmentData* mutable_segmentdata(int index);
  inline ::PictureInfo_SegmentData* add_segmentdata();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_SegmentData >&
      segmentdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_SegmentData >*
      mutable_segmentdata();

  // optional bool segementAbsData = 12;
  inline bool has_segementabsdata() const;
  inline void clear_segementabsdata();
  static const int kSegementAbsDataFieldNumber = 12;
  inline bool segementabsdata() const;
  inline void set_segementabsdata(bool value);

  // repeated int32 frameCtxOrigin = 13;
  inline int framectxorigin_size() const;
  inline void clear_framectxorigin();
  static const int kFrameCtxOriginFieldNumber = 13;
  inline ::google::protobuf::int32 framectxorigin(int index) const;
  inline void set_framectxorigin(int index, ::google::protobuf::int32 value);
  inline void add_framectxorigin(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      framectxorigin() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_framectxorigin();

  // required int32 frameCtxIdx = 14;
  inline bool has_framectxidx() const;
  inline void clear_framectxidx();
  static const int kFrameCtxIdxFieldNumber = 14;
  inline ::google::protobuf::int32 framectxidx() const;
  inline void set_framectxidx(::google::protobuf::int32 value);

  // required int32 numBytes = 15;
  inline bool has_numbytes() const;
  inline void clear_numbytes();
  static const int kNumBytesFieldNumber = 15;
  inline ::google::protobuf::int32 numbytes() const;
  inline void set_numbytes(::google::protobuf::int32 value);

  // required int32 numBools = 16;
  inline bool has_numbools() const;
  inline void clear_numbools();
  static const int kNumBoolsFieldNumber = 16;
  inline ::google::protobuf::int32 numbools() const;
  inline void set_numbools(::google::protobuf::int32 value);

  // repeated .PictureInfo.Stat stats = 17;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 17;
  inline const ::PictureInfo_Stat& stats(int index) const;
  inline ::PictureInfo_Stat* mutable_stats(int index);
  inline ::PictureInfo_Stat* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat >*
      mutable_stats();

  // required .PictureInfo.NumericTree probs = 18;
  inline bool has_probs() const;
  inline void clear_probs();
  static const int kProbsFieldNumber = 18;
  inline const ::PictureInfo_NumericTree& probs() const;
  inline ::PictureInfo_NumericTree* mutable_probs();
  inline ::PictureInfo_NumericTree* release_probs();
  inline void set_allocated_probs(::PictureInfo_NumericTree* probs);

  // required .PictureInfo.NumericTree counts = 19;
  inline bool has_counts() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 19;
  inline const ::PictureInfo_NumericTree& counts() const;
  inline ::PictureInfo_NumericTree* mutable_counts();
  inline ::PictureInfo_NumericTree* release_counts();
  inline void set_allocated_counts(::PictureInfo_NumericTree* counts);

  // repeated int32 tileColPos = 20;
  inline int tilecolpos_size() const;
  inline void clear_tilecolpos();
  static const int kTileColPosFieldNumber = 20;
  inline ::google::protobuf::int32 tilecolpos(int index) const;
  inline void set_tilecolpos(int index, ::google::protobuf::int32 value);
  inline void add_tilecolpos(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tilecolpos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tilecolpos();

  // repeated int32 tileRowPos = 21;
  inline int tilerowpos_size() const;
  inline void clear_tilerowpos();
  static const int kTileRowPosFieldNumber = 21;
  inline ::google::protobuf::int32 tilerowpos(int index) const;
  inline void set_tilerowpos(int index, ::google::protobuf::int32 value);
  inline void add_tilerowpos(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tilerowpos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tilerowpos();

  // repeated int32 lfRefDelta = 22;
  inline int lfrefdelta_size() const;
  inline void clear_lfrefdelta();
  static const int kLfRefDeltaFieldNumber = 22;
  inline ::google::protobuf::int32 lfrefdelta(int index) const;
  inline void set_lfrefdelta(int index, ::google::protobuf::int32 value);
  inline void add_lfrefdelta(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lfrefdelta() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lfrefdelta();

  // repeated int32 lfModeDelta = 23;
  inline int lfmodedelta_size() const;
  inline void clear_lfmodedelta();
  static const int kLfModeDeltaFieldNumber = 23;
  inline ::google::protobuf::int32 lfmodedelta(int index) const;
  inline void set_lfmodedelta(int index, ::google::protobuf::int32 value);
  inline void add_lfmodedelta(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lfmodedelta() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lfmodedelta();

  // repeated int32 signBias = 24;
  inline int signbias_size() const;
  inline void clear_signbias();
  static const int kSignBiasFieldNumber = 24;
  inline ::google::protobuf::int32 signbias(int index) const;
  inline void set_signbias(int index, ::google::protobuf::int32 value);
  inline void add_signbias(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      signbias() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_signbias();

  // repeated int32 tileSizes = 25;
  inline int tilesizes_size() const;
  inline void clear_tilesizes();
  static const int kTileSizesFieldNumber = 25;
  inline ::google::protobuf::int32 tilesizes(int index) const;
  inline void set_tilesizes(int index, ::google::protobuf::int32 value);
  inline void add_tilesizes(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tilesizes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tilesizes();

  // optional .Thumbnail thumbnail = 26;
  inline bool has_thumbnail() const;
  inline void clear_thumbnail();
  static const int kThumbnailFieldNumber = 26;
  inline const ::Thumbnail& thumbnail() const;
  inline ::Thumbnail* mutable_thumbnail();
  inline ::Thumbnail* release_thumbnail();
  inline void set_allocated_thumbnail(::Thumbnail* thumbnail);

  // required int32 bytePos = 27;
  inline bool has_bytepos() const;
  inline void clear_bytepos();
  static const int kBytePosFieldNumber = 27;
  inline ::google::protobuf::int32 bytepos() const;
  inline void set_bytepos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PictureInfo)
 private:
  inline void set_has_decodeindex();
  inline void clear_has_decodeindex();
  inline void set_has_displayindex();
  inline void clear_has_displayindex();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_isinter();
  inline void clear_has_isinter();
  inline void set_has_digest();
  inline void clear_has_digest();
  inline void set_has_lastrefidx();
  inline void clear_has_lastrefidx();
  inline void set_has_goldrefidx();
  inline void clear_has_goldrefidx();
  inline void set_has_altrefidx();
  inline void clear_has_altrefidx();
  inline void set_has_segementabsdata();
  inline void clear_has_segementabsdata();
  inline void set_has_framectxidx();
  inline void clear_has_framectxidx();
  inline void set_has_numbytes();
  inline void clear_has_numbytes();
  inline void set_has_numbools();
  inline void clear_has_numbools();
  inline void set_has_probs();
  inline void clear_has_probs();
  inline void set_has_counts();
  inline void clear_has_counts();
  inline void set_has_thumbnail();
  inline void clear_has_thumbnail();
  inline void set_has_bytepos();
  inline void clear_has_bytepos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 decodeindex_;
  ::google::protobuf::int32 displayindex_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::std::string* digest_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > references_;
  ::google::protobuf::int32 lastrefidx_;
  bool isinter_;
  bool segementabsdata_;
  ::google::protobuf::int32 goldrefidx_;
  ::google::protobuf::int32 altrefidx_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_SegmentData > segmentdata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > framectxorigin_;
  ::google::protobuf::int32 framectxidx_;
  ::google::protobuf::int32 numbytes_;
  ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat > stats_;
  ::PictureInfo_NumericTree* probs_;
  ::PictureInfo_NumericTree* counts_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tilecolpos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tilerowpos_;
  ::google::protobuf::int32 numbools_;
  ::google::protobuf::int32 bytepos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lfrefdelta_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lfmodedelta_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > signbias_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tilesizes_;
  ::Thumbnail* thumbnail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureInfo* default_instance_;
};
// -------------------------------------------------------------------

class PictureImgs : public ::google::protobuf::Message {
 public:
  PictureImgs();
  virtual ~PictureImgs();

  PictureImgs(const PictureImgs& from);

  inline PictureImgs& operator=(const PictureImgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PictureImgs& default_instance();

  void Swap(PictureImgs* other);

  // implements Message ----------------------------------------------

  PictureImgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PictureImgs& from);
  void MergeFrom(const PictureImgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes predImg = 1;
  inline bool has_predimg() const;
  inline void clear_predimg();
  static const int kPredImgFieldNumber = 1;
  inline const ::std::string& predimg() const;
  inline void set_predimg(const ::std::string& value);
  inline void set_predimg(const char* value);
  inline void set_predimg(const void* value, size_t size);
  inline ::std::string* mutable_predimg();
  inline ::std::string* release_predimg();
  inline void set_allocated_predimg(::std::string* predimg);

  // required bytes resImg = 2;
  inline bool has_resimg() const;
  inline void clear_resimg();
  static const int kResImgFieldNumber = 2;
  inline const ::std::string& resimg() const;
  inline void set_resimg(const ::std::string& value);
  inline void set_resimg(const char* value);
  inline void set_resimg(const void* value, size_t size);
  inline ::std::string* mutable_resimg();
  inline ::std::string* release_resimg();
  inline void set_allocated_resimg(::std::string* resimg);

  // required bytes reconImg = 3;
  inline bool has_reconimg() const;
  inline void clear_reconimg();
  static const int kReconImgFieldNumber = 3;
  inline const ::std::string& reconimg() const;
  inline void set_reconimg(const ::std::string& value);
  inline void set_reconimg(const char* value);
  inline void set_reconimg(const void* value, size_t size);
  inline ::std::string* mutable_reconimg();
  inline ::std::string* release_reconimg();
  inline void set_allocated_reconimg(::std::string* reconimg);

  // required bytes finalImg = 4;
  inline bool has_finalimg() const;
  inline void clear_finalimg();
  static const int kFinalImgFieldNumber = 4;
  inline const ::std::string& finalimg() const;
  inline void set_finalimg(const ::std::string& value);
  inline void set_finalimg(const char* value);
  inline void set_finalimg(const void* value, size_t size);
  inline ::std::string* mutable_finalimg();
  inline ::std::string* release_finalimg();
  inline void set_allocated_finalimg(::std::string* finalimg);

  // @@protoc_insertion_point(class_scope:PictureImgs)
 private:
  inline void set_has_predimg();
  inline void clear_has_predimg();
  inline void set_has_resimg();
  inline void clear_has_resimg();
  inline void set_has_reconimg();
  inline void clear_has_reconimg();
  inline void set_has_finalimg();
  inline void clear_has_finalimg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* predimg_;
  ::std::string* resimg_;
  ::std::string* reconimg_;
  ::std::string* finalimg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static PictureImgs* default_instance_;
};
// -------------------------------------------------------------------

class BlockInfo_MV_MVPredictor : public ::google::protobuf::Message {
 public:
  BlockInfo_MV_MVPredictor();
  virtual ~BlockInfo_MV_MVPredictor();

  BlockInfo_MV_MVPredictor(const BlockInfo_MV_MVPredictor& from);

  inline BlockInfo_MV_MVPredictor& operator=(const BlockInfo_MV_MVPredictor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo_MV_MVPredictor& default_instance();

  void Swap(BlockInfo_MV_MVPredictor* other);

  // implements Message ----------------------------------------------

  BlockInfo_MV_MVPredictor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockInfo_MV_MVPredictor& from);
  void MergeFrom(const BlockInfo_MV_MVPredictor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .BlockInfo.MV predictor = 1;
  inline bool has_predictor() const;
  inline void clear_predictor();
  static const int kPredictorFieldNumber = 1;
  inline const ::BlockInfo_MV& predictor() const;
  inline ::BlockInfo_MV* mutable_predictor();
  inline ::BlockInfo_MV* release_predictor();
  inline void set_allocated_predictor(::BlockInfo_MV* predictor);

  // optional .Point loc = 2;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 2;
  inline const ::Point& loc() const;
  inline ::Point* mutable_loc();
  inline ::Point* release_loc();
  inline void set_allocated_loc(::Point* loc);

  // optional string label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:BlockInfo.MV.MVPredictor)
 private:
  inline void set_has_predictor();
  inline void clear_has_predictor();
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BlockInfo_MV* predictor_;
  ::Point* loc_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static BlockInfo_MV_MVPredictor* default_instance_;
};
// -------------------------------------------------------------------

class BlockInfo_MV : public ::google::protobuf::Message {
 public:
  BlockInfo_MV();
  virtual ~BlockInfo_MV();

  BlockInfo_MV(const BlockInfo_MV& from);

  inline BlockInfo_MV& operator=(const BlockInfo_MV& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo_MV& default_instance();

  void Swap(BlockInfo_MV* other);

  // implements Message ----------------------------------------------

  BlockInfo_MV* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockInfo_MV& from);
  void MergeFrom(const BlockInfo_MV& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlockInfo_MV_MVPredictor MVPredictor;

  // accessors -------------------------------------------------------

  // required sint32 mvx = 1;
  inline bool has_mvx() const;
  inline void clear_mvx();
  static const int kMvxFieldNumber = 1;
  inline ::google::protobuf::int32 mvx() const;
  inline void set_mvx(::google::protobuf::int32 value);

  // required sint32 mvy = 2;
  inline bool has_mvy() const;
  inline void clear_mvy();
  static const int kMvyFieldNumber = 2;
  inline ::google::protobuf::int32 mvy() const;
  inline void set_mvy(::google::protobuf::int32 value);

  // optional sint32 deltax = 3;
  inline bool has_deltax() const;
  inline void clear_deltax();
  static const int kDeltaxFieldNumber = 3;
  inline ::google::protobuf::int32 deltax() const;
  inline void set_deltax(::google::protobuf::int32 value);

  // optional sint32 deltay = 4;
  inline bool has_deltay() const;
  inline void clear_deltay();
  static const int kDeltayFieldNumber = 4;
  inline ::google::protobuf::int32 deltay() const;
  inline void set_deltay(::google::protobuf::int32 value);

  // required int32 ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);

  // repeated .BlockInfo.MV.MVPredictor preds = 6;
  inline int preds_size() const;
  inline void clear_preds();
  static const int kPredsFieldNumber = 6;
  inline const ::BlockInfo_MV_MVPredictor& preds(int index) const;
  inline ::BlockInfo_MV_MVPredictor* mutable_preds(int index);
  inline ::BlockInfo_MV_MVPredictor* add_preds();
  inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV_MVPredictor >&
      preds() const;
  inline ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV_MVPredictor >*
      mutable_preds();

  // @@protoc_insertion_point(class_scope:BlockInfo.MV)
 private:
  inline void set_has_mvx();
  inline void clear_has_mvx();
  inline void set_has_mvy();
  inline void clear_has_mvy();
  inline void set_has_deltax();
  inline void clear_has_deltax();
  inline void set_has_deltay();
  inline void clear_has_deltay();
  inline void set_has_ref();
  inline void clear_has_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mvx_;
  ::google::protobuf::int32 mvy_;
  ::google::protobuf::int32 deltax_;
  ::google::protobuf::int32 deltay_;
  ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV_MVPredictor > preds_;
  ::google::protobuf::int32 ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static BlockInfo_MV* default_instance_;
};
// -------------------------------------------------------------------

class BlockInfo : public ::google::protobuf::Message {
 public:
  BlockInfo();
  virtual ~BlockInfo();

  BlockInfo(const BlockInfo& from);

  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo& default_instance();

  void Swap(BlockInfo* other);

  // implements Message ----------------------------------------------

  BlockInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockInfo& from);
  void MergeFrom(const BlockInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlockInfo_MV MV;

  typedef BlockInfo_TxSize TxSize;
  static const TxSize TX_4X4 = BlockInfo_TxSize_TX_4X4;
  static const TxSize TX_8X8 = BlockInfo_TxSize_TX_8X8;
  static const TxSize TX_16X16 = BlockInfo_TxSize_TX_16X16;
  static const TxSize TX_32X32 = BlockInfo_TxSize_TX_32X32;
  static inline bool TxSize_IsValid(int value) {
    return BlockInfo_TxSize_IsValid(value);
  }
  static const TxSize TxSize_MIN =
    BlockInfo_TxSize_TxSize_MIN;
  static const TxSize TxSize_MAX =
    BlockInfo_TxSize_TxSize_MAX;
  static const int TxSize_ARRAYSIZE =
    BlockInfo_TxSize_TxSize_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TxSize_descriptor() {
    return BlockInfo_TxSize_descriptor();
  }
  static inline const ::std::string& TxSize_Name(TxSize value) {
    return BlockInfo_TxSize_Name(value);
  }
  static inline bool TxSize_Parse(const ::std::string& name,
      TxSize* value) {
    return BlockInfo_TxSize_Parse(name, value);
  }

  typedef BlockInfo_SwitchableFilterType SwitchableFilterType;
  static const SwitchableFilterType MC_8TAP = BlockInfo_SwitchableFilterType_MC_8TAP;
  static const SwitchableFilterType MC_8TAP_SHARP = BlockInfo_SwitchableFilterType_MC_8TAP_SHARP;
  static const SwitchableFilterType MC_8TAP_SMOOTH = BlockInfo_SwitchableFilterType_MC_8TAP_SMOOTH;
  static inline bool SwitchableFilterType_IsValid(int value) {
    return BlockInfo_SwitchableFilterType_IsValid(value);
  }
  static const SwitchableFilterType SwitchableFilterType_MIN =
    BlockInfo_SwitchableFilterType_SwitchableFilterType_MIN;
  static const SwitchableFilterType SwitchableFilterType_MAX =
    BlockInfo_SwitchableFilterType_SwitchableFilterType_MAX;
  static const int SwitchableFilterType_ARRAYSIZE =
    BlockInfo_SwitchableFilterType_SwitchableFilterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SwitchableFilterType_descriptor() {
    return BlockInfo_SwitchableFilterType_descriptor();
  }
  static inline const ::std::string& SwitchableFilterType_Name(SwitchableFilterType value) {
    return BlockInfo_SwitchableFilterType_Name(value);
  }
  static inline bool SwitchableFilterType_Parse(const ::std::string& name,
      SwitchableFilterType* value) {
    return BlockInfo_SwitchableFilterType_Parse(name, value);
  }

  typedef BlockInfo_IntraMode IntraMode;
  static const IntraMode DC_PRED = BlockInfo_IntraMode_DC_PRED;
  static const IntraMode V_PRED = BlockInfo_IntraMode_V_PRED;
  static const IntraMode H_PRED = BlockInfo_IntraMode_H_PRED;
  static const IntraMode D45_PRED = BlockInfo_IntraMode_D45_PRED;
  static const IntraMode D135_PRED = BlockInfo_IntraMode_D135_PRED;
  static const IntraMode D117_PRED = BlockInfo_IntraMode_D117_PRED;
  static const IntraMode D153_PRED = BlockInfo_IntraMode_D153_PRED;
  static const IntraMode D207_PRED = BlockInfo_IntraMode_D207_PRED;
  static const IntraMode D63_PRED = BlockInfo_IntraMode_D63_PRED;
  static const IntraMode TM_PRED = BlockInfo_IntraMode_TM_PRED;
  static inline bool IntraMode_IsValid(int value) {
    return BlockInfo_IntraMode_IsValid(value);
  }
  static const IntraMode IntraMode_MIN =
    BlockInfo_IntraMode_IntraMode_MIN;
  static const IntraMode IntraMode_MAX =
    BlockInfo_IntraMode_IntraMode_MAX;
  static const int IntraMode_ARRAYSIZE =
    BlockInfo_IntraMode_IntraMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IntraMode_descriptor() {
    return BlockInfo_IntraMode_descriptor();
  }
  static inline const ::std::string& IntraMode_Name(IntraMode value) {
    return BlockInfo_IntraMode_Name(value);
  }
  static inline bool IntraMode_Parse(const ::std::string& name,
      IntraMode* value) {
    return BlockInfo_IntraMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Point p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline const ::Point& p() const;
  inline ::Point* mutable_p();
  inline ::Point* release_p();
  inline void set_allocated_p(::Point* p);

  // required int32 w = 2;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 2;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 3;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 3;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // required int32 bools = 4;
  inline bool has_bools() const;
  inline void clear_bools();
  static const int kBoolsFieldNumber = 4;
  inline ::google::protobuf::int32 bools() const;
  inline void set_bools(::google::protobuf::int32 value);

  // required int32 bits = 5;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 5;
  inline ::google::protobuf::int32 bits() const;
  inline void set_bits(::google::protobuf::int32 value);

  // required bool intra = 6;
  inline bool has_intra() const;
  inline void clear_intra();
  static const int kIntraFieldNumber = 6;
  inline bool intra() const;
  inline void set_intra(bool value);

  // optional int32 segment_id = 7;
  inline bool has_segment_id() const;
  inline void clear_segment_id();
  static const int kSegmentIdFieldNumber = 7;
  inline ::google::protobuf::int32 segment_id() const;
  inline void set_segment_id(::google::protobuf::int32 value);

  // optional .BlockInfo.TxSize txSize = 8;
  inline bool has_txsize() const;
  inline void clear_txsize();
  static const int kTxSizeFieldNumber = 8;
  inline ::BlockInfo_TxSize txsize() const;
  inline void set_txsize(::BlockInfo_TxSize value);

  // required bool skip = 9;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 9;
  inline bool skip() const;
  inline void set_skip(bool value);

  // repeated .BlockInfo.MV mv = 10;
  inline int mv_size() const;
  inline void clear_mv();
  static const int kMvFieldNumber = 10;
  inline const ::BlockInfo_MV& mv(int index) const;
  inline ::BlockInfo_MV* mutable_mv(int index);
  inline ::BlockInfo_MV* add_mv();
  inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV >&
      mv() const;
  inline ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV >*
      mutable_mv();

  // optional .BlockInfo.SwitchableFilterType mcType = 11;
  inline bool has_mctype() const;
  inline void clear_mctype();
  static const int kMcTypeFieldNumber = 11;
  inline ::BlockInfo_SwitchableFilterType mctype() const;
  inline void set_mctype(::BlockInfo_SwitchableFilterType value);

  // optional .BlockInfo.IntraMode intraLumaMode = 12;
  inline bool has_intralumamode() const;
  inline void clear_intralumamode();
  static const int kIntraLumaModeFieldNumber = 12;
  inline ::BlockInfo_IntraMode intralumamode() const;
  inline void set_intralumamode(::BlockInfo_IntraMode value);

  // optional .BlockInfo.IntraMode intraChromaMode = 13;
  inline bool has_intrachromamode() const;
  inline void clear_intrachromamode();
  static const int kIntraChromaModeFieldNumber = 13;
  inline ::BlockInfo_IntraMode intrachromamode() const;
  inline void set_intrachromamode(::BlockInfo_IntraMode value);

  // required int32 coeffBools = 14;
  inline bool has_coeffbools() const;
  inline void clear_coeffbools();
  static const int kCoeffBoolsFieldNumber = 14;
  inline ::google::protobuf::int32 coeffbools() const;
  inline void set_coeffbools(::google::protobuf::int32 value);

  // required int32 coeffBits = 15;
  inline bool has_coeffbits() const;
  inline void clear_coeffbits();
  static const int kCoeffBitsFieldNumber = 15;
  inline ::google::protobuf::int32 coeffbits() const;
  inline void set_coeffbits(::google::protobuf::int32 value);

  // required int32 lumaDcScale = 16;
  inline bool has_lumadcscale() const;
  inline void clear_lumadcscale();
  static const int kLumaDcScaleFieldNumber = 16;
  inline ::google::protobuf::int32 lumadcscale() const;
  inline void set_lumadcscale(::google::protobuf::int32 value);

  // required int32 lumaAcScale = 17;
  inline bool has_lumaacscale() const;
  inline void clear_lumaacscale();
  static const int kLumaAcScaleFieldNumber = 17;
  inline ::google::protobuf::int32 lumaacscale() const;
  inline void set_lumaacscale(::google::protobuf::int32 value);

  // required int32 chromaDcScale = 18;
  inline bool has_chromadcscale() const;
  inline void clear_chromadcscale();
  static const int kChromaDcScaleFieldNumber = 18;
  inline ::google::protobuf::int32 chromadcscale() const;
  inline void set_chromadcscale(::google::protobuf::int32 value);

  // required int32 chromaAcScale = 19;
  inline bool has_chromaacscale() const;
  inline void clear_chromaacscale();
  static const int kChromaAcScaleFieldNumber = 19;
  inline ::google::protobuf::int32 chromaacscale() const;
  inline void set_chromaacscale(::google::protobuf::int32 value);

  // required int32 bitPos = 20;
  inline bool has_bitpos() const;
  inline void clear_bitpos();
  static const int kBitPosFieldNumber = 20;
  inline ::google::protobuf::int32 bitpos() const;
  inline void set_bitpos(::google::protobuf::int32 value);

  // required int32 syntaxStart = 21;
  inline bool has_syntaxstart() const;
  inline void clear_syntaxstart();
  static const int kSyntaxStartFieldNumber = 21;
  inline ::google::protobuf::int32 syntaxstart() const;
  inline void set_syntaxstart(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BlockInfo)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_bools();
  inline void clear_has_bools();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_intra();
  inline void clear_has_intra();
  inline void set_has_segment_id();
  inline void clear_has_segment_id();
  inline void set_has_txsize();
  inline void clear_has_txsize();
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_mctype();
  inline void clear_has_mctype();
  inline void set_has_intralumamode();
  inline void clear_has_intralumamode();
  inline void set_has_intrachromamode();
  inline void clear_has_intrachromamode();
  inline void set_has_coeffbools();
  inline void clear_has_coeffbools();
  inline void set_has_coeffbits();
  inline void clear_has_coeffbits();
  inline void set_has_lumadcscale();
  inline void clear_has_lumadcscale();
  inline void set_has_lumaacscale();
  inline void clear_has_lumaacscale();
  inline void set_has_chromadcscale();
  inline void clear_has_chromadcscale();
  inline void set_has_chromaacscale();
  inline void clear_has_chromaacscale();
  inline void set_has_bitpos();
  inline void clear_has_bitpos();
  inline void set_has_syntaxstart();
  inline void clear_has_syntaxstart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Point* p_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::google::protobuf::int32 bools_;
  ::google::protobuf::int32 bits_;
  ::google::protobuf::int32 segment_id_;
  bool intra_;
  bool skip_;
  int txsize_;
  int mctype_;
  ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV > mv_;
  int intralumamode_;
  int intrachromamode_;
  ::google::protobuf::int32 coeffbools_;
  ::google::protobuf::int32 coeffbits_;
  ::google::protobuf::int32 lumadcscale_;
  ::google::protobuf::int32 lumaacscale_;
  ::google::protobuf::int32 chromadcscale_;
  ::google::protobuf::int32 chromaacscale_;
  ::google::protobuf::int32 bitpos_;
  ::google::protobuf::int32 syntaxstart_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static BlockInfo* default_instance_;
};
// -------------------------------------------------------------------

class Coeffs : public ::google::protobuf::Message {
 public:
  Coeffs();
  virtual ~Coeffs();

  Coeffs(const Coeffs& from);

  inline Coeffs& operator=(const Coeffs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coeffs& default_instance();

  void Swap(Coeffs* other);

  // implements Message ----------------------------------------------

  Coeffs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coeffs& from);
  void MergeFrom(const Coeffs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 coeffs = 1;
  inline int coeffs_size() const;
  inline void clear_coeffs();
  static const int kCoeffsFieldNumber = 1;
  inline ::google::protobuf::int32 coeffs(int index) const;
  inline void set_coeffs(int index, ::google::protobuf::int32 value);
  inline void add_coeffs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      coeffs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_coeffs();

  // @@protoc_insertion_point(class_scope:Coeffs)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > coeffs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static Coeffs* default_instance_;
};
// -------------------------------------------------------------------

class SuperblockInfo : public ::google::protobuf::Message {
 public:
  SuperblockInfo();
  virtual ~SuperblockInfo();

  SuperblockInfo(const SuperblockInfo& from);

  inline SuperblockInfo& operator=(const SuperblockInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperblockInfo& default_instance();

  void Swap(SuperblockInfo* other);

  // implements Message ----------------------------------------------

  SuperblockInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuperblockInfo& from);
  void MergeFrom(const SuperblockInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sbCol = 1;
  inline bool has_sbcol() const;
  inline void clear_sbcol();
  static const int kSbColFieldNumber = 1;
  inline ::google::protobuf::int32 sbcol() const;
  inline void set_sbcol(::google::protobuf::int32 value);

  // required int32 sbRow = 2;
  inline bool has_sbrow() const;
  inline void clear_sbrow();
  static const int kSbRowFieldNumber = 2;
  inline ::google::protobuf::int32 sbrow() const;
  inline void set_sbrow(::google::protobuf::int32 value);

  // repeated .BlockInfo blocks = 3;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 3;
  inline const ::BlockInfo& blocks(int index) const;
  inline ::BlockInfo* mutable_blocks(int index);
  inline ::BlockInfo* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::BlockInfo >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:SuperblockInfo)
 private:
  inline void set_has_sbcol();
  inline void clear_has_sbcol();
  inline void set_has_sbrow();
  inline void clear_has_sbrow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 sbcol_;
  ::google::protobuf::int32 sbrow_;
  ::google::protobuf::RepeatedPtrField< ::BlockInfo > blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static SuperblockInfo* default_instance_;
};
// -------------------------------------------------------------------

class SuperblockRegion : public ::google::protobuf::Message {
 public:
  SuperblockRegion();
  virtual ~SuperblockRegion();

  SuperblockRegion(const SuperblockRegion& from);

  inline SuperblockRegion& operator=(const SuperblockRegion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperblockRegion& default_instance();

  void Swap(SuperblockRegion* other);

  // implements Message ----------------------------------------------

  SuperblockRegion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuperblockRegion& from);
  void MergeFrom(const SuperblockRegion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sbCol = 1;
  inline bool has_sbcol() const;
  inline void clear_sbcol();
  static const int kSbColFieldNumber = 1;
  inline ::google::protobuf::int32 sbcol() const;
  inline void set_sbcol(::google::protobuf::int32 value);

  // required int32 sbRow = 2;
  inline bool has_sbrow() const;
  inline void clear_sbrow();
  static const int kSbRowFieldNumber = 2;
  inline ::google::protobuf::int32 sbrow() const;
  inline void set_sbrow(::google::protobuf::int32 value);

  // required int32 sbCols = 3;
  inline bool has_sbcols() const;
  inline void clear_sbcols();
  static const int kSbColsFieldNumber = 3;
  inline ::google::protobuf::int32 sbcols() const;
  inline void set_sbcols(::google::protobuf::int32 value);

  // required int32 sbRows = 4;
  inline bool has_sbrows() const;
  inline void clear_sbrows();
  static const int kSbRowsFieldNumber = 4;
  inline ::google::protobuf::int32 sbrows() const;
  inline void set_sbrows(::google::protobuf::int32 value);

  // repeated .SuperblockInfo superblocks = 5;
  inline int superblocks_size() const;
  inline void clear_superblocks();
  static const int kSuperblocksFieldNumber = 5;
  inline const ::SuperblockInfo& superblocks(int index) const;
  inline ::SuperblockInfo* mutable_superblocks(int index);
  inline ::SuperblockInfo* add_superblocks();
  inline const ::google::protobuf::RepeatedPtrField< ::SuperblockInfo >&
      superblocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::SuperblockInfo >*
      mutable_superblocks();

  // @@protoc_insertion_point(class_scope:SuperblockRegion)
 private:
  inline void set_has_sbcol();
  inline void clear_has_sbcol();
  inline void set_has_sbrow();
  inline void clear_has_sbrow();
  inline void set_has_sbcols();
  inline void clear_has_sbcols();
  inline void set_has_sbrows();
  inline void clear_has_sbrows();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 sbcol_;
  ::google::protobuf::int32 sbrow_;
  ::google::protobuf::int32 sbcols_;
  ::google::protobuf::int32 sbrows_;
  ::google::protobuf::RepeatedPtrField< ::SuperblockInfo > superblocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static SuperblockRegion* default_instance_;
};
// -------------------------------------------------------------------

class RawBytes : public ::google::protobuf::Message {
 public:
  RawBytes();
  virtual ~RawBytes();

  RawBytes(const RawBytes& from);

  inline RawBytes& operator=(const RawBytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBytes& default_instance();

  void Swap(RawBytes* other);

  // implements Message ----------------------------------------------

  RawBytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawBytes& from);
  void MergeFrom(const RawBytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:RawBytes)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_vp9bat_2eproto();
  friend void protobuf_AssignDesc_vp9bat_2eproto();
  friend void protobuf_ShutdownFile_vp9bat_2eproto();

  void InitAsDefaultInstance();
  static RawBytes* default_instance_;
};
// ===================================================================


// ===================================================================

// Point

// required int32 x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Point::x() const {
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Point::y() const {
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// VP9Syntax_SyntaxElement

// required string name = 1;
inline bool VP9Syntax_SyntaxElement::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VP9Syntax_SyntaxElement::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VP9Syntax_SyntaxElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VP9Syntax_SyntaxElement::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VP9Syntax_SyntaxElement::name() const {
  return *name_;
}
inline void VP9Syntax_SyntaxElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VP9Syntax_SyntaxElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VP9Syntax_SyntaxElement::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VP9Syntax_SyntaxElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VP9Syntax_SyntaxElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VP9Syntax_SyntaxElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 intValue = 2;
inline bool VP9Syntax_SyntaxElement::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VP9Syntax_SyntaxElement::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VP9Syntax_SyntaxElement::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VP9Syntax_SyntaxElement::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 VP9Syntax_SyntaxElement::intvalue() const {
  return intvalue_;
}
inline void VP9Syntax_SyntaxElement::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional string stringValue = 3;
inline bool VP9Syntax_SyntaxElement::has_stringvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VP9Syntax_SyntaxElement::set_has_stringvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VP9Syntax_SyntaxElement::clear_has_stringvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VP9Syntax_SyntaxElement::clear_stringvalue() {
  if (stringvalue_ != &::google::protobuf::internal::GetEmptyString()) {
    stringvalue_->clear();
  }
  clear_has_stringvalue();
}
inline const ::std::string& VP9Syntax_SyntaxElement::stringvalue() const {
  return *stringvalue_;
}
inline void VP9Syntax_SyntaxElement::set_stringvalue(const ::std::string& value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::GetEmptyString()) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void VP9Syntax_SyntaxElement::set_stringvalue(const char* value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::GetEmptyString()) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void VP9Syntax_SyntaxElement::set_stringvalue(const char* value, size_t size) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::GetEmptyString()) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VP9Syntax_SyntaxElement::mutable_stringvalue() {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::GetEmptyString()) {
    stringvalue_ = new ::std::string;
  }
  return stringvalue_;
}
inline ::std::string* VP9Syntax_SyntaxElement::release_stringvalue() {
  clear_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = stringvalue_;
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VP9Syntax_SyntaxElement::set_allocated_stringvalue(::std::string* stringvalue) {
  if (stringvalue_ != &::google::protobuf::internal::GetEmptyString()) {
    delete stringvalue_;
  }
  if (stringvalue) {
    set_has_stringvalue();
    stringvalue_ = stringvalue;
  } else {
    clear_has_stringvalue();
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 bcRange = 4;
inline bool VP9Syntax_SyntaxElement::has_bcrange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VP9Syntax_SyntaxElement::set_has_bcrange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VP9Syntax_SyntaxElement::clear_has_bcrange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VP9Syntax_SyntaxElement::clear_bcrange() {
  bcrange_ = 0;
  clear_has_bcrange();
}
inline ::google::protobuf::int32 VP9Syntax_SyntaxElement::bcrange() const {
  return bcrange_;
}
inline void VP9Syntax_SyntaxElement::set_bcrange(::google::protobuf::int32 value) {
  set_has_bcrange();
  bcrange_ = value;
}

// optional int32 bcValue = 5;
inline bool VP9Syntax_SyntaxElement::has_bcvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VP9Syntax_SyntaxElement::set_has_bcvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VP9Syntax_SyntaxElement::clear_has_bcvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VP9Syntax_SyntaxElement::clear_bcvalue() {
  bcvalue_ = 0;
  clear_has_bcvalue();
}
inline ::google::protobuf::int32 VP9Syntax_SyntaxElement::bcvalue() const {
  return bcvalue_;
}
inline void VP9Syntax_SyntaxElement::set_bcvalue(::google::protobuf::int32 value) {
  set_has_bcvalue();
  bcvalue_ = value;
}

// -------------------------------------------------------------------

// VP9Syntax

// repeated .VP9Syntax.SyntaxElement elements = 1;
inline int VP9Syntax::elements_size() const {
  return elements_.size();
}
inline void VP9Syntax::clear_elements() {
  elements_.Clear();
}
inline const ::VP9Syntax_SyntaxElement& VP9Syntax::elements(int index) const {
  return elements_.Get(index);
}
inline ::VP9Syntax_SyntaxElement* VP9Syntax::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::VP9Syntax_SyntaxElement* VP9Syntax::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VP9Syntax_SyntaxElement >&
VP9Syntax::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::VP9Syntax_SyntaxElement >*
VP9Syntax::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// LoopFilterEdge

// required .Point p = 1;
inline bool LoopFilterEdge::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoopFilterEdge::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoopFilterEdge::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoopFilterEdge::clear_p() {
  if (p_ != NULL) p_->::Point::Clear();
  clear_has_p();
}
inline const ::Point& LoopFilterEdge::p() const {
  return p_ != NULL ? *p_ : *default_instance_->p_;
}
inline ::Point* LoopFilterEdge::mutable_p() {
  set_has_p();
  if (p_ == NULL) p_ = new ::Point;
  return p_;
}
inline ::Point* LoopFilterEdge::release_p() {
  clear_has_p();
  ::Point* temp = p_;
  p_ = NULL;
  return temp;
}
inline void LoopFilterEdge::set_allocated_p(::Point* p) {
  delete p_;
  p_ = p;
  if (p) {
    set_has_p();
  } else {
    clear_has_p();
  }
}

// required int32 component = 2;
inline bool LoopFilterEdge::has_component() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoopFilterEdge::set_has_component() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoopFilterEdge::clear_has_component() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoopFilterEdge::clear_component() {
  component_ = 0;
  clear_has_component();
}
inline ::google::protobuf::int32 LoopFilterEdge::component() const {
  return component_;
}
inline void LoopFilterEdge::set_component(::google::protobuf::int32 value) {
  set_has_component();
  component_ = value;
}

// required bool isVertical = 3;
inline bool LoopFilterEdge::has_isvertical() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoopFilterEdge::set_has_isvertical() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoopFilterEdge::clear_has_isvertical() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoopFilterEdge::clear_isvertical() {
  isvertical_ = false;
  clear_has_isvertical();
}
inline bool LoopFilterEdge::isvertical() const {
  return isvertical_;
}
inline void LoopFilterEdge::set_isvertical(bool value) {
  set_has_isvertical();
  isvertical_ = value;
}

// required .LoopFilterEdge.FilterType type = 4;
inline bool LoopFilterEdge::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoopFilterEdge::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoopFilterEdge::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoopFilterEdge::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::LoopFilterEdge_FilterType LoopFilterEdge::type() const {
  return static_cast< ::LoopFilterEdge_FilterType >(type_);
}
inline void LoopFilterEdge::set_type(::LoopFilterEdge_FilterType value) {
  assert(::LoopFilterEdge_FilterType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 level = 5;
inline bool LoopFilterEdge::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoopFilterEdge::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoopFilterEdge::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoopFilterEdge::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 LoopFilterEdge::level() const {
  return level_;
}
inline void LoopFilterEdge::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// SampleBlock

// required .Point p = 1;
inline bool SampleBlock::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SampleBlock::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SampleBlock::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SampleBlock::clear_p() {
  if (p_ != NULL) p_->::Point::Clear();
  clear_has_p();
}
inline const ::Point& SampleBlock::p() const {
  return p_ != NULL ? *p_ : *default_instance_->p_;
}
inline ::Point* SampleBlock::mutable_p() {
  set_has_p();
  if (p_ == NULL) p_ = new ::Point;
  return p_;
}
inline ::Point* SampleBlock::release_p() {
  clear_has_p();
  ::Point* temp = p_;
  p_ = NULL;
  return temp;
}
inline void SampleBlock::set_allocated_p(::Point* p) {
  delete p_;
  p_ = p;
  if (p) {
    set_has_p();
  } else {
    clear_has_p();
  }
}

// required int32 w = 3;
inline bool SampleBlock::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SampleBlock::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SampleBlock::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SampleBlock::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 SampleBlock::w() const {
  return w_;
}
inline void SampleBlock::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 4;
inline bool SampleBlock::has_h() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SampleBlock::set_has_h() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SampleBlock::clear_has_h() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SampleBlock::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 SampleBlock::h() const {
  return h_;
}
inline void SampleBlock::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// required bytes samples = 5;
inline bool SampleBlock::has_samples() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SampleBlock::set_has_samples() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SampleBlock::clear_has_samples() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SampleBlock::clear_samples() {
  if (samples_ != &::google::protobuf::internal::GetEmptyString()) {
    samples_->clear();
  }
  clear_has_samples();
}
inline const ::std::string& SampleBlock::samples() const {
  return *samples_;
}
inline void SampleBlock::set_samples(const ::std::string& value) {
  set_has_samples();
  if (samples_ == &::google::protobuf::internal::GetEmptyString()) {
    samples_ = new ::std::string;
  }
  samples_->assign(value);
}
inline void SampleBlock::set_samples(const char* value) {
  set_has_samples();
  if (samples_ == &::google::protobuf::internal::GetEmptyString()) {
    samples_ = new ::std::string;
  }
  samples_->assign(value);
}
inline void SampleBlock::set_samples(const void* value, size_t size) {
  set_has_samples();
  if (samples_ == &::google::protobuf::internal::GetEmptyString()) {
    samples_ = new ::std::string;
  }
  samples_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SampleBlock::mutable_samples() {
  set_has_samples();
  if (samples_ == &::google::protobuf::internal::GetEmptyString()) {
    samples_ = new ::std::string;
  }
  return samples_;
}
inline ::std::string* SampleBlock::release_samples() {
  clear_has_samples();
  if (samples_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = samples_;
    samples_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SampleBlock::set_allocated_samples(::std::string* samples) {
  if (samples_ != &::google::protobuf::internal::GetEmptyString()) {
    delete samples_;
  }
  if (samples) {
    set_has_samples();
    samples_ = samples;
  } else {
    clear_has_samples();
    samples_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes flags = 6;
inline bool SampleBlock::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SampleBlock::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SampleBlock::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SampleBlock::clear_flags() {
  if (flags_ != &::google::protobuf::internal::GetEmptyString()) {
    flags_->clear();
  }
  clear_has_flags();
}
inline const ::std::string& SampleBlock::flags() const {
  return *flags_;
}
inline void SampleBlock::set_flags(const ::std::string& value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void SampleBlock::set_flags(const char* value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void SampleBlock::set_flags(const void* value, size_t size) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SampleBlock::mutable_flags() {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  return flags_;
}
inline ::std::string* SampleBlock::release_flags() {
  clear_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = flags_;
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SampleBlock::set_allocated_flags(::std::string* flags) {
  if (flags_ != &::google::protobuf::internal::GetEmptyString()) {
    delete flags_;
  }
  if (flags) {
    set_has_flags();
    flags_ = flags;
  } else {
    clear_has_flags();
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// StreamInfo

// required int32 numPics = 1;
inline bool StreamInfo::has_numpics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamInfo::set_has_numpics() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamInfo::clear_has_numpics() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamInfo::clear_numpics() {
  numpics_ = 0;
  clear_has_numpics();
}
inline ::google::protobuf::int32 StreamInfo::numpics() const {
  return numpics_;
}
inline void StreamInfo::set_numpics(::google::protobuf::int32 value) {
  set_has_numpics();
  numpics_ = value;
}

// -------------------------------------------------------------------

// Thumbnail

// required int32 w = 1;
inline bool Thumbnail::has_w() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thumbnail::set_has_w() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thumbnail::clear_has_w() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thumbnail::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Thumbnail::w() const {
  return w_;
}
inline void Thumbnail::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 2;
inline bool Thumbnail::has_h() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thumbnail::set_has_h() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thumbnail::clear_has_h() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thumbnail::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 Thumbnail::h() const {
  return h_;
}
inline void Thumbnail::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// required bytes thumbnail = 3;
inline bool Thumbnail::has_thumbnail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thumbnail::set_has_thumbnail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thumbnail::clear_has_thumbnail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thumbnail::clear_thumbnail() {
  if (thumbnail_ != &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_->clear();
  }
  clear_has_thumbnail();
}
inline const ::std::string& Thumbnail::thumbnail() const {
  return *thumbnail_;
}
inline void Thumbnail::set_thumbnail(const ::std::string& value) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(value);
}
inline void Thumbnail::set_thumbnail(const char* value) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(value);
}
inline void Thumbnail::set_thumbnail(const void* value, size_t size) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Thumbnail::mutable_thumbnail() {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyString()) {
    thumbnail_ = new ::std::string;
  }
  return thumbnail_;
}
inline ::std::string* Thumbnail::release_thumbnail() {
  clear_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = thumbnail_;
    thumbnail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Thumbnail::set_allocated_thumbnail(::std::string* thumbnail) {
  if (thumbnail_ != &::google::protobuf::internal::GetEmptyString()) {
    delete thumbnail_;
  }
  if (thumbnail) {
    set_has_thumbnail();
    thumbnail_ = thumbnail;
  } else {
    clear_has_thumbnail();
    thumbnail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PictureInfo_SegmentData

// required bool skip = 1;
inline bool PictureInfo_SegmentData::has_skip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureInfo_SegmentData::set_has_skip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureInfo_SegmentData::clear_has_skip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureInfo_SegmentData::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool PictureInfo_SegmentData::skip() const {
  return skip_;
}
inline void PictureInfo_SegmentData::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
}

// optional sint32 altQ = 2;
inline bool PictureInfo_SegmentData::has_altq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureInfo_SegmentData::set_has_altq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureInfo_SegmentData::clear_has_altq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureInfo_SegmentData::clear_altq() {
  altq_ = 0;
  clear_has_altq();
}
inline ::google::protobuf::int32 PictureInfo_SegmentData::altq() const {
  return altq_;
}
inline void PictureInfo_SegmentData::set_altq(::google::protobuf::int32 value) {
  set_has_altq();
  altq_ = value;
}

// optional sint32 altLF = 3;
inline bool PictureInfo_SegmentData::has_altlf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PictureInfo_SegmentData::set_has_altlf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PictureInfo_SegmentData::clear_has_altlf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PictureInfo_SegmentData::clear_altlf() {
  altlf_ = 0;
  clear_has_altlf();
}
inline ::google::protobuf::int32 PictureInfo_SegmentData::altlf() const {
  return altlf_;
}
inline void PictureInfo_SegmentData::set_altlf(::google::protobuf::int32 value) {
  set_has_altlf();
  altlf_ = value;
}

// optional int32 ref = 4;
inline bool PictureInfo_SegmentData::has_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PictureInfo_SegmentData::set_has_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PictureInfo_SegmentData::clear_has_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PictureInfo_SegmentData::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 PictureInfo_SegmentData::ref() const {
  return ref_;
}
inline void PictureInfo_SegmentData::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// -------------------------------------------------------------------

// PictureInfo_Stat_StatEntry

// required string name = 1;
inline bool PictureInfo_Stat_StatEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureInfo_Stat_StatEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureInfo_Stat_StatEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureInfo_Stat_StatEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PictureInfo_Stat_StatEntry::name() const {
  return *name_;
}
inline void PictureInfo_Stat_StatEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PictureInfo_Stat_StatEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PictureInfo_Stat_StatEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureInfo_Stat_StatEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PictureInfo_Stat_StatEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureInfo_Stat_StatEntry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 value = 2;
inline bool PictureInfo_Stat_StatEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureInfo_Stat_StatEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureInfo_Stat_StatEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureInfo_Stat_StatEntry::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 PictureInfo_Stat_StatEntry::value() const {
  return value_;
}
inline void PictureInfo_Stat_StatEntry::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PictureInfo_Stat

// required string name = 1;
inline bool PictureInfo_Stat::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureInfo_Stat::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureInfo_Stat::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureInfo_Stat::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PictureInfo_Stat::name() const {
  return *name_;
}
inline void PictureInfo_Stat::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PictureInfo_Stat::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PictureInfo_Stat::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureInfo_Stat::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PictureInfo_Stat::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureInfo_Stat::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .PictureInfo.Stat.StatEntry rawEntries = 2;
inline int PictureInfo_Stat::rawentries_size() const {
  return rawentries_.size();
}
inline void PictureInfo_Stat::clear_rawentries() {
  rawentries_.Clear();
}
inline const ::PictureInfo_Stat_StatEntry& PictureInfo_Stat::rawentries(int index) const {
  return rawentries_.Get(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::mutable_rawentries(int index) {
  return rawentries_.Mutable(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::add_rawentries() {
  return rawentries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
PictureInfo_Stat::rawentries() const {
  return rawentries_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
PictureInfo_Stat::mutable_rawentries() {
  return &rawentries_;
}

// repeated .PictureInfo.Stat.StatEntry areaNormalizedEntries = 3;
inline int PictureInfo_Stat::areanormalizedentries_size() const {
  return areanormalizedentries_.size();
}
inline void PictureInfo_Stat::clear_areanormalizedentries() {
  areanormalizedentries_.Clear();
}
inline const ::PictureInfo_Stat_StatEntry& PictureInfo_Stat::areanormalizedentries(int index) const {
  return areanormalizedentries_.Get(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::mutable_areanormalizedentries(int index) {
  return areanormalizedentries_.Mutable(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::add_areanormalizedentries() {
  return areanormalizedentries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
PictureInfo_Stat::areanormalizedentries() const {
  return areanormalizedentries_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
PictureInfo_Stat::mutable_areanormalizedentries() {
  return &areanormalizedentries_;
}

// repeated .PictureInfo.Stat.StatEntry bitsNormalizedEntries = 4;
inline int PictureInfo_Stat::bitsnormalizedentries_size() const {
  return bitsnormalizedentries_.size();
}
inline void PictureInfo_Stat::clear_bitsnormalizedentries() {
  bitsnormalizedentries_.Clear();
}
inline const ::PictureInfo_Stat_StatEntry& PictureInfo_Stat::bitsnormalizedentries(int index) const {
  return bitsnormalizedentries_.Get(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::mutable_bitsnormalizedentries(int index) {
  return bitsnormalizedentries_.Mutable(index);
}
inline ::PictureInfo_Stat_StatEntry* PictureInfo_Stat::add_bitsnormalizedentries() {
  return bitsnormalizedentries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >&
PictureInfo_Stat::bitsnormalizedentries() const {
  return bitsnormalizedentries_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat_StatEntry >*
PictureInfo_Stat::mutable_bitsnormalizedentries() {
  return &bitsnormalizedentries_;
}

// -------------------------------------------------------------------

// PictureInfo_NumericTree

// optional int32 nodeValue = 1;
inline bool PictureInfo_NumericTree::has_nodevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureInfo_NumericTree::set_has_nodevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureInfo_NumericTree::clear_has_nodevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureInfo_NumericTree::clear_nodevalue() {
  nodevalue_ = 0;
  clear_has_nodevalue();
}
inline ::google::protobuf::int32 PictureInfo_NumericTree::nodevalue() const {
  return nodevalue_;
}
inline void PictureInfo_NumericTree::set_nodevalue(::google::protobuf::int32 value) {
  set_has_nodevalue();
  nodevalue_ = value;
}

// optional string nodeName = 2;
inline bool PictureInfo_NumericTree::has_nodename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureInfo_NumericTree::set_has_nodename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureInfo_NumericTree::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureInfo_NumericTree::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::GetEmptyString()) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& PictureInfo_NumericTree::nodename() const {
  return *nodename_;
}
inline void PictureInfo_NumericTree::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyString()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void PictureInfo_NumericTree::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyString()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void PictureInfo_NumericTree::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyString()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureInfo_NumericTree::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyString()) {
    nodename_ = new ::std::string;
  }
  return nodename_;
}
inline ::std::string* PictureInfo_NumericTree::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureInfo_NumericTree::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::GetEmptyString()) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .PictureInfo.NumericTree children = 3;
inline int PictureInfo_NumericTree::children_size() const {
  return children_.size();
}
inline void PictureInfo_NumericTree::clear_children() {
  children_.Clear();
}
inline const ::PictureInfo_NumericTree& PictureInfo_NumericTree::children(int index) const {
  return children_.Get(index);
}
inline ::PictureInfo_NumericTree* PictureInfo_NumericTree::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::PictureInfo_NumericTree* PictureInfo_NumericTree::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_NumericTree >&
PictureInfo_NumericTree::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_NumericTree >*
PictureInfo_NumericTree::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// PictureInfo

// required int32 decodeIndex = 1;
inline bool PictureInfo::has_decodeindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureInfo::set_has_decodeindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureInfo::clear_has_decodeindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureInfo::clear_decodeindex() {
  decodeindex_ = 0;
  clear_has_decodeindex();
}
inline ::google::protobuf::int32 PictureInfo::decodeindex() const {
  return decodeindex_;
}
inline void PictureInfo::set_decodeindex(::google::protobuf::int32 value) {
  set_has_decodeindex();
  decodeindex_ = value;
}

// required int32 displayIndex = 2;
inline bool PictureInfo::has_displayindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureInfo::set_has_displayindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureInfo::clear_has_displayindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureInfo::clear_displayindex() {
  displayindex_ = 0;
  clear_has_displayindex();
}
inline ::google::protobuf::int32 PictureInfo::displayindex() const {
  return displayindex_;
}
inline void PictureInfo::set_displayindex(::google::protobuf::int32 value) {
  set_has_displayindex();
  displayindex_ = value;
}

// required int32 w = 3;
inline bool PictureInfo::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PictureInfo::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PictureInfo::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PictureInfo::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 PictureInfo::w() const {
  return w_;
}
inline void PictureInfo::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 4;
inline bool PictureInfo::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PictureInfo::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PictureInfo::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PictureInfo::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 PictureInfo::h() const {
  return h_;
}
inline void PictureInfo::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// required bool isInter = 5;
inline bool PictureInfo::has_isinter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PictureInfo::set_has_isinter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PictureInfo::clear_has_isinter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PictureInfo::clear_isinter() {
  isinter_ = false;
  clear_has_isinter();
}
inline bool PictureInfo::isinter() const {
  return isinter_;
}
inline void PictureInfo::set_isinter(bool value) {
  set_has_isinter();
  isinter_ = value;
}

// optional string digest = 6;
inline bool PictureInfo::has_digest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PictureInfo::set_has_digest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PictureInfo::clear_has_digest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PictureInfo::clear_digest() {
  if (digest_ != &::google::protobuf::internal::GetEmptyString()) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& PictureInfo::digest() const {
  return *digest_;
}
inline void PictureInfo::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyString()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void PictureInfo::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyString()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void PictureInfo::set_digest(const char* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyString()) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureInfo::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyString()) {
    digest_ = new ::std::string;
  }
  return digest_;
}
inline ::std::string* PictureInfo::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureInfo::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::GetEmptyString()) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated int32 references = 7;
inline int PictureInfo::references_size() const {
  return references_.size();
}
inline void PictureInfo::clear_references() {
  references_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::references(int index) const {
  return references_.Get(index);
}
inline void PictureInfo::set_references(int index, ::google::protobuf::int32 value) {
  references_.Set(index, value);
}
inline void PictureInfo::add_references(::google::protobuf::int32 value) {
  references_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::references() const {
  return references_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_references() {
  return &references_;
}

// optional int32 lastRefIdx = 8;
inline bool PictureInfo::has_lastrefidx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PictureInfo::set_has_lastrefidx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PictureInfo::clear_has_lastrefidx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PictureInfo::clear_lastrefidx() {
  lastrefidx_ = 0;
  clear_has_lastrefidx();
}
inline ::google::protobuf::int32 PictureInfo::lastrefidx() const {
  return lastrefidx_;
}
inline void PictureInfo::set_lastrefidx(::google::protobuf::int32 value) {
  set_has_lastrefidx();
  lastrefidx_ = value;
}

// optional int32 goldRefIdx = 9;
inline bool PictureInfo::has_goldrefidx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PictureInfo::set_has_goldrefidx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PictureInfo::clear_has_goldrefidx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PictureInfo::clear_goldrefidx() {
  goldrefidx_ = 0;
  clear_has_goldrefidx();
}
inline ::google::protobuf::int32 PictureInfo::goldrefidx() const {
  return goldrefidx_;
}
inline void PictureInfo::set_goldrefidx(::google::protobuf::int32 value) {
  set_has_goldrefidx();
  goldrefidx_ = value;
}

// optional int32 altRefIdx = 10;
inline bool PictureInfo::has_altrefidx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PictureInfo::set_has_altrefidx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PictureInfo::clear_has_altrefidx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PictureInfo::clear_altrefidx() {
  altrefidx_ = 0;
  clear_has_altrefidx();
}
inline ::google::protobuf::int32 PictureInfo::altrefidx() const {
  return altrefidx_;
}
inline void PictureInfo::set_altrefidx(::google::protobuf::int32 value) {
  set_has_altrefidx();
  altrefidx_ = value;
}

// repeated .PictureInfo.SegmentData segmentData = 11;
inline int PictureInfo::segmentdata_size() const {
  return segmentdata_.size();
}
inline void PictureInfo::clear_segmentdata() {
  segmentdata_.Clear();
}
inline const ::PictureInfo_SegmentData& PictureInfo::segmentdata(int index) const {
  return segmentdata_.Get(index);
}
inline ::PictureInfo_SegmentData* PictureInfo::mutable_segmentdata(int index) {
  return segmentdata_.Mutable(index);
}
inline ::PictureInfo_SegmentData* PictureInfo::add_segmentdata() {
  return segmentdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_SegmentData >&
PictureInfo::segmentdata() const {
  return segmentdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_SegmentData >*
PictureInfo::mutable_segmentdata() {
  return &segmentdata_;
}

// optional bool segementAbsData = 12;
inline bool PictureInfo::has_segementabsdata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PictureInfo::set_has_segementabsdata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PictureInfo::clear_has_segementabsdata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PictureInfo::clear_segementabsdata() {
  segementabsdata_ = false;
  clear_has_segementabsdata();
}
inline bool PictureInfo::segementabsdata() const {
  return segementabsdata_;
}
inline void PictureInfo::set_segementabsdata(bool value) {
  set_has_segementabsdata();
  segementabsdata_ = value;
}

// repeated int32 frameCtxOrigin = 13;
inline int PictureInfo::framectxorigin_size() const {
  return framectxorigin_.size();
}
inline void PictureInfo::clear_framectxorigin() {
  framectxorigin_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::framectxorigin(int index) const {
  return framectxorigin_.Get(index);
}
inline void PictureInfo::set_framectxorigin(int index, ::google::protobuf::int32 value) {
  framectxorigin_.Set(index, value);
}
inline void PictureInfo::add_framectxorigin(::google::protobuf::int32 value) {
  framectxorigin_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::framectxorigin() const {
  return framectxorigin_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_framectxorigin() {
  return &framectxorigin_;
}

// required int32 frameCtxIdx = 14;
inline bool PictureInfo::has_framectxidx() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PictureInfo::set_has_framectxidx() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PictureInfo::clear_has_framectxidx() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PictureInfo::clear_framectxidx() {
  framectxidx_ = 0;
  clear_has_framectxidx();
}
inline ::google::protobuf::int32 PictureInfo::framectxidx() const {
  return framectxidx_;
}
inline void PictureInfo::set_framectxidx(::google::protobuf::int32 value) {
  set_has_framectxidx();
  framectxidx_ = value;
}

// required int32 numBytes = 15;
inline bool PictureInfo::has_numbytes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PictureInfo::set_has_numbytes() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PictureInfo::clear_has_numbytes() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PictureInfo::clear_numbytes() {
  numbytes_ = 0;
  clear_has_numbytes();
}
inline ::google::protobuf::int32 PictureInfo::numbytes() const {
  return numbytes_;
}
inline void PictureInfo::set_numbytes(::google::protobuf::int32 value) {
  set_has_numbytes();
  numbytes_ = value;
}

// required int32 numBools = 16;
inline bool PictureInfo::has_numbools() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PictureInfo::set_has_numbools() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PictureInfo::clear_has_numbools() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PictureInfo::clear_numbools() {
  numbools_ = 0;
  clear_has_numbools();
}
inline ::google::protobuf::int32 PictureInfo::numbools() const {
  return numbools_;
}
inline void PictureInfo::set_numbools(::google::protobuf::int32 value) {
  set_has_numbools();
  numbools_ = value;
}

// repeated .PictureInfo.Stat stats = 17;
inline int PictureInfo::stats_size() const {
  return stats_.size();
}
inline void PictureInfo::clear_stats() {
  stats_.Clear();
}
inline const ::PictureInfo_Stat& PictureInfo::stats(int index) const {
  return stats_.Get(index);
}
inline ::PictureInfo_Stat* PictureInfo::mutable_stats(int index) {
  return stats_.Mutable(index);
}
inline ::PictureInfo_Stat* PictureInfo::add_stats() {
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat >&
PictureInfo::stats() const {
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::PictureInfo_Stat >*
PictureInfo::mutable_stats() {
  return &stats_;
}

// required .PictureInfo.NumericTree probs = 18;
inline bool PictureInfo::has_probs() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PictureInfo::set_has_probs() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PictureInfo::clear_has_probs() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PictureInfo::clear_probs() {
  if (probs_ != NULL) probs_->::PictureInfo_NumericTree::Clear();
  clear_has_probs();
}
inline const ::PictureInfo_NumericTree& PictureInfo::probs() const {
  return probs_ != NULL ? *probs_ : *default_instance_->probs_;
}
inline ::PictureInfo_NumericTree* PictureInfo::mutable_probs() {
  set_has_probs();
  if (probs_ == NULL) probs_ = new ::PictureInfo_NumericTree;
  return probs_;
}
inline ::PictureInfo_NumericTree* PictureInfo::release_probs() {
  clear_has_probs();
  ::PictureInfo_NumericTree* temp = probs_;
  probs_ = NULL;
  return temp;
}
inline void PictureInfo::set_allocated_probs(::PictureInfo_NumericTree* probs) {
  delete probs_;
  probs_ = probs;
  if (probs) {
    set_has_probs();
  } else {
    clear_has_probs();
  }
}

// required .PictureInfo.NumericTree counts = 19;
inline bool PictureInfo::has_counts() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PictureInfo::set_has_counts() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PictureInfo::clear_has_counts() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PictureInfo::clear_counts() {
  if (counts_ != NULL) counts_->::PictureInfo_NumericTree::Clear();
  clear_has_counts();
}
inline const ::PictureInfo_NumericTree& PictureInfo::counts() const {
  return counts_ != NULL ? *counts_ : *default_instance_->counts_;
}
inline ::PictureInfo_NumericTree* PictureInfo::mutable_counts() {
  set_has_counts();
  if (counts_ == NULL) counts_ = new ::PictureInfo_NumericTree;
  return counts_;
}
inline ::PictureInfo_NumericTree* PictureInfo::release_counts() {
  clear_has_counts();
  ::PictureInfo_NumericTree* temp = counts_;
  counts_ = NULL;
  return temp;
}
inline void PictureInfo::set_allocated_counts(::PictureInfo_NumericTree* counts) {
  delete counts_;
  counts_ = counts;
  if (counts) {
    set_has_counts();
  } else {
    clear_has_counts();
  }
}

// repeated int32 tileColPos = 20;
inline int PictureInfo::tilecolpos_size() const {
  return tilecolpos_.size();
}
inline void PictureInfo::clear_tilecolpos() {
  tilecolpos_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::tilecolpos(int index) const {
  return tilecolpos_.Get(index);
}
inline void PictureInfo::set_tilecolpos(int index, ::google::protobuf::int32 value) {
  tilecolpos_.Set(index, value);
}
inline void PictureInfo::add_tilecolpos(::google::protobuf::int32 value) {
  tilecolpos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::tilecolpos() const {
  return tilecolpos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_tilecolpos() {
  return &tilecolpos_;
}

// repeated int32 tileRowPos = 21;
inline int PictureInfo::tilerowpos_size() const {
  return tilerowpos_.size();
}
inline void PictureInfo::clear_tilerowpos() {
  tilerowpos_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::tilerowpos(int index) const {
  return tilerowpos_.Get(index);
}
inline void PictureInfo::set_tilerowpos(int index, ::google::protobuf::int32 value) {
  tilerowpos_.Set(index, value);
}
inline void PictureInfo::add_tilerowpos(::google::protobuf::int32 value) {
  tilerowpos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::tilerowpos() const {
  return tilerowpos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_tilerowpos() {
  return &tilerowpos_;
}

// repeated int32 lfRefDelta = 22;
inline int PictureInfo::lfrefdelta_size() const {
  return lfrefdelta_.size();
}
inline void PictureInfo::clear_lfrefdelta() {
  lfrefdelta_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::lfrefdelta(int index) const {
  return lfrefdelta_.Get(index);
}
inline void PictureInfo::set_lfrefdelta(int index, ::google::protobuf::int32 value) {
  lfrefdelta_.Set(index, value);
}
inline void PictureInfo::add_lfrefdelta(::google::protobuf::int32 value) {
  lfrefdelta_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::lfrefdelta() const {
  return lfrefdelta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_lfrefdelta() {
  return &lfrefdelta_;
}

// repeated int32 lfModeDelta = 23;
inline int PictureInfo::lfmodedelta_size() const {
  return lfmodedelta_.size();
}
inline void PictureInfo::clear_lfmodedelta() {
  lfmodedelta_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::lfmodedelta(int index) const {
  return lfmodedelta_.Get(index);
}
inline void PictureInfo::set_lfmodedelta(int index, ::google::protobuf::int32 value) {
  lfmodedelta_.Set(index, value);
}
inline void PictureInfo::add_lfmodedelta(::google::protobuf::int32 value) {
  lfmodedelta_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::lfmodedelta() const {
  return lfmodedelta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_lfmodedelta() {
  return &lfmodedelta_;
}

// repeated int32 signBias = 24;
inline int PictureInfo::signbias_size() const {
  return signbias_.size();
}
inline void PictureInfo::clear_signbias() {
  signbias_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::signbias(int index) const {
  return signbias_.Get(index);
}
inline void PictureInfo::set_signbias(int index, ::google::protobuf::int32 value) {
  signbias_.Set(index, value);
}
inline void PictureInfo::add_signbias(::google::protobuf::int32 value) {
  signbias_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::signbias() const {
  return signbias_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_signbias() {
  return &signbias_;
}

// repeated int32 tileSizes = 25;
inline int PictureInfo::tilesizes_size() const {
  return tilesizes_.size();
}
inline void PictureInfo::clear_tilesizes() {
  tilesizes_.Clear();
}
inline ::google::protobuf::int32 PictureInfo::tilesizes(int index) const {
  return tilesizes_.Get(index);
}
inline void PictureInfo::set_tilesizes(int index, ::google::protobuf::int32 value) {
  tilesizes_.Set(index, value);
}
inline void PictureInfo::add_tilesizes(::google::protobuf::int32 value) {
  tilesizes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PictureInfo::tilesizes() const {
  return tilesizes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PictureInfo::mutable_tilesizes() {
  return &tilesizes_;
}

// optional .Thumbnail thumbnail = 26;
inline bool PictureInfo::has_thumbnail() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PictureInfo::set_has_thumbnail() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PictureInfo::clear_has_thumbnail() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PictureInfo::clear_thumbnail() {
  if (thumbnail_ != NULL) thumbnail_->::Thumbnail::Clear();
  clear_has_thumbnail();
}
inline const ::Thumbnail& PictureInfo::thumbnail() const {
  return thumbnail_ != NULL ? *thumbnail_ : *default_instance_->thumbnail_;
}
inline ::Thumbnail* PictureInfo::mutable_thumbnail() {
  set_has_thumbnail();
  if (thumbnail_ == NULL) thumbnail_ = new ::Thumbnail;
  return thumbnail_;
}
inline ::Thumbnail* PictureInfo::release_thumbnail() {
  clear_has_thumbnail();
  ::Thumbnail* temp = thumbnail_;
  thumbnail_ = NULL;
  return temp;
}
inline void PictureInfo::set_allocated_thumbnail(::Thumbnail* thumbnail) {
  delete thumbnail_;
  thumbnail_ = thumbnail;
  if (thumbnail) {
    set_has_thumbnail();
  } else {
    clear_has_thumbnail();
  }
}

// required int32 bytePos = 27;
inline bool PictureInfo::has_bytepos() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PictureInfo::set_has_bytepos() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PictureInfo::clear_has_bytepos() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PictureInfo::clear_bytepos() {
  bytepos_ = 0;
  clear_has_bytepos();
}
inline ::google::protobuf::int32 PictureInfo::bytepos() const {
  return bytepos_;
}
inline void PictureInfo::set_bytepos(::google::protobuf::int32 value) {
  set_has_bytepos();
  bytepos_ = value;
}

// -------------------------------------------------------------------

// PictureImgs

// required bytes predImg = 1;
inline bool PictureImgs::has_predimg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureImgs::set_has_predimg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureImgs::clear_has_predimg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureImgs::clear_predimg() {
  if (predimg_ != &::google::protobuf::internal::GetEmptyString()) {
    predimg_->clear();
  }
  clear_has_predimg();
}
inline const ::std::string& PictureImgs::predimg() const {
  return *predimg_;
}
inline void PictureImgs::set_predimg(const ::std::string& value) {
  set_has_predimg();
  if (predimg_ == &::google::protobuf::internal::GetEmptyString()) {
    predimg_ = new ::std::string;
  }
  predimg_->assign(value);
}
inline void PictureImgs::set_predimg(const char* value) {
  set_has_predimg();
  if (predimg_ == &::google::protobuf::internal::GetEmptyString()) {
    predimg_ = new ::std::string;
  }
  predimg_->assign(value);
}
inline void PictureImgs::set_predimg(const void* value, size_t size) {
  set_has_predimg();
  if (predimg_ == &::google::protobuf::internal::GetEmptyString()) {
    predimg_ = new ::std::string;
  }
  predimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureImgs::mutable_predimg() {
  set_has_predimg();
  if (predimg_ == &::google::protobuf::internal::GetEmptyString()) {
    predimg_ = new ::std::string;
  }
  return predimg_;
}
inline ::std::string* PictureImgs::release_predimg() {
  clear_has_predimg();
  if (predimg_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = predimg_;
    predimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureImgs::set_allocated_predimg(::std::string* predimg) {
  if (predimg_ != &::google::protobuf::internal::GetEmptyString()) {
    delete predimg_;
  }
  if (predimg) {
    set_has_predimg();
    predimg_ = predimg;
  } else {
    clear_has_predimg();
    predimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes resImg = 2;
inline bool PictureImgs::has_resimg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureImgs::set_has_resimg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureImgs::clear_has_resimg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureImgs::clear_resimg() {
  if (resimg_ != &::google::protobuf::internal::GetEmptyString()) {
    resimg_->clear();
  }
  clear_has_resimg();
}
inline const ::std::string& PictureImgs::resimg() const {
  return *resimg_;
}
inline void PictureImgs::set_resimg(const ::std::string& value) {
  set_has_resimg();
  if (resimg_ == &::google::protobuf::internal::GetEmptyString()) {
    resimg_ = new ::std::string;
  }
  resimg_->assign(value);
}
inline void PictureImgs::set_resimg(const char* value) {
  set_has_resimg();
  if (resimg_ == &::google::protobuf::internal::GetEmptyString()) {
    resimg_ = new ::std::string;
  }
  resimg_->assign(value);
}
inline void PictureImgs::set_resimg(const void* value, size_t size) {
  set_has_resimg();
  if (resimg_ == &::google::protobuf::internal::GetEmptyString()) {
    resimg_ = new ::std::string;
  }
  resimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureImgs::mutable_resimg() {
  set_has_resimg();
  if (resimg_ == &::google::protobuf::internal::GetEmptyString()) {
    resimg_ = new ::std::string;
  }
  return resimg_;
}
inline ::std::string* PictureImgs::release_resimg() {
  clear_has_resimg();
  if (resimg_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = resimg_;
    resimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureImgs::set_allocated_resimg(::std::string* resimg) {
  if (resimg_ != &::google::protobuf::internal::GetEmptyString()) {
    delete resimg_;
  }
  if (resimg) {
    set_has_resimg();
    resimg_ = resimg;
  } else {
    clear_has_resimg();
    resimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes reconImg = 3;
inline bool PictureImgs::has_reconimg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PictureImgs::set_has_reconimg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PictureImgs::clear_has_reconimg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PictureImgs::clear_reconimg() {
  if (reconimg_ != &::google::protobuf::internal::GetEmptyString()) {
    reconimg_->clear();
  }
  clear_has_reconimg();
}
inline const ::std::string& PictureImgs::reconimg() const {
  return *reconimg_;
}
inline void PictureImgs::set_reconimg(const ::std::string& value) {
  set_has_reconimg();
  if (reconimg_ == &::google::protobuf::internal::GetEmptyString()) {
    reconimg_ = new ::std::string;
  }
  reconimg_->assign(value);
}
inline void PictureImgs::set_reconimg(const char* value) {
  set_has_reconimg();
  if (reconimg_ == &::google::protobuf::internal::GetEmptyString()) {
    reconimg_ = new ::std::string;
  }
  reconimg_->assign(value);
}
inline void PictureImgs::set_reconimg(const void* value, size_t size) {
  set_has_reconimg();
  if (reconimg_ == &::google::protobuf::internal::GetEmptyString()) {
    reconimg_ = new ::std::string;
  }
  reconimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureImgs::mutable_reconimg() {
  set_has_reconimg();
  if (reconimg_ == &::google::protobuf::internal::GetEmptyString()) {
    reconimg_ = new ::std::string;
  }
  return reconimg_;
}
inline ::std::string* PictureImgs::release_reconimg() {
  clear_has_reconimg();
  if (reconimg_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = reconimg_;
    reconimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureImgs::set_allocated_reconimg(::std::string* reconimg) {
  if (reconimg_ != &::google::protobuf::internal::GetEmptyString()) {
    delete reconimg_;
  }
  if (reconimg) {
    set_has_reconimg();
    reconimg_ = reconimg;
  } else {
    clear_has_reconimg();
    reconimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes finalImg = 4;
inline bool PictureImgs::has_finalimg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PictureImgs::set_has_finalimg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PictureImgs::clear_has_finalimg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PictureImgs::clear_finalimg() {
  if (finalimg_ != &::google::protobuf::internal::GetEmptyString()) {
    finalimg_->clear();
  }
  clear_has_finalimg();
}
inline const ::std::string& PictureImgs::finalimg() const {
  return *finalimg_;
}
inline void PictureImgs::set_finalimg(const ::std::string& value) {
  set_has_finalimg();
  if (finalimg_ == &::google::protobuf::internal::GetEmptyString()) {
    finalimg_ = new ::std::string;
  }
  finalimg_->assign(value);
}
inline void PictureImgs::set_finalimg(const char* value) {
  set_has_finalimg();
  if (finalimg_ == &::google::protobuf::internal::GetEmptyString()) {
    finalimg_ = new ::std::string;
  }
  finalimg_->assign(value);
}
inline void PictureImgs::set_finalimg(const void* value, size_t size) {
  set_has_finalimg();
  if (finalimg_ == &::google::protobuf::internal::GetEmptyString()) {
    finalimg_ = new ::std::string;
  }
  finalimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PictureImgs::mutable_finalimg() {
  set_has_finalimg();
  if (finalimg_ == &::google::protobuf::internal::GetEmptyString()) {
    finalimg_ = new ::std::string;
  }
  return finalimg_;
}
inline ::std::string* PictureImgs::release_finalimg() {
  clear_has_finalimg();
  if (finalimg_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = finalimg_;
    finalimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PictureImgs::set_allocated_finalimg(::std::string* finalimg) {
  if (finalimg_ != &::google::protobuf::internal::GetEmptyString()) {
    delete finalimg_;
  }
  if (finalimg) {
    set_has_finalimg();
    finalimg_ = finalimg;
  } else {
    clear_has_finalimg();
    finalimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// BlockInfo_MV_MVPredictor

// required .BlockInfo.MV predictor = 1;
inline bool BlockInfo_MV_MVPredictor::has_predictor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockInfo_MV_MVPredictor::set_has_predictor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockInfo_MV_MVPredictor::clear_has_predictor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockInfo_MV_MVPredictor::clear_predictor() {
  if (predictor_ != NULL) predictor_->::BlockInfo_MV::Clear();
  clear_has_predictor();
}
inline const ::BlockInfo_MV& BlockInfo_MV_MVPredictor::predictor() const {
  return predictor_ != NULL ? *predictor_ : *default_instance_->predictor_;
}
inline ::BlockInfo_MV* BlockInfo_MV_MVPredictor::mutable_predictor() {
  set_has_predictor();
  if (predictor_ == NULL) predictor_ = new ::BlockInfo_MV;
  return predictor_;
}
inline ::BlockInfo_MV* BlockInfo_MV_MVPredictor::release_predictor() {
  clear_has_predictor();
  ::BlockInfo_MV* temp = predictor_;
  predictor_ = NULL;
  return temp;
}
inline void BlockInfo_MV_MVPredictor::set_allocated_predictor(::BlockInfo_MV* predictor) {
  delete predictor_;
  predictor_ = predictor;
  if (predictor) {
    set_has_predictor();
  } else {
    clear_has_predictor();
  }
}

// optional .Point loc = 2;
inline bool BlockInfo_MV_MVPredictor::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockInfo_MV_MVPredictor::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockInfo_MV_MVPredictor::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockInfo_MV_MVPredictor::clear_loc() {
  if (loc_ != NULL) loc_->::Point::Clear();
  clear_has_loc();
}
inline const ::Point& BlockInfo_MV_MVPredictor::loc() const {
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
}
inline ::Point* BlockInfo_MV_MVPredictor::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::Point;
  return loc_;
}
inline ::Point* BlockInfo_MV_MVPredictor::release_loc() {
  clear_has_loc();
  ::Point* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void BlockInfo_MV_MVPredictor::set_allocated_loc(::Point* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional string label = 3;
inline bool BlockInfo_MV_MVPredictor::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockInfo_MV_MVPredictor::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockInfo_MV_MVPredictor::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockInfo_MV_MVPredictor::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& BlockInfo_MV_MVPredictor::label() const {
  return *label_;
}
inline void BlockInfo_MV_MVPredictor::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void BlockInfo_MV_MVPredictor::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void BlockInfo_MV_MVPredictor::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockInfo_MV_MVPredictor::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* BlockInfo_MV_MVPredictor::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void BlockInfo_MV_MVPredictor::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// BlockInfo_MV

// required sint32 mvx = 1;
inline bool BlockInfo_MV::has_mvx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockInfo_MV::set_has_mvx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockInfo_MV::clear_has_mvx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockInfo_MV::clear_mvx() {
  mvx_ = 0;
  clear_has_mvx();
}
inline ::google::protobuf::int32 BlockInfo_MV::mvx() const {
  return mvx_;
}
inline void BlockInfo_MV::set_mvx(::google::protobuf::int32 value) {
  set_has_mvx();
  mvx_ = value;
}

// required sint32 mvy = 2;
inline bool BlockInfo_MV::has_mvy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockInfo_MV::set_has_mvy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockInfo_MV::clear_has_mvy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockInfo_MV::clear_mvy() {
  mvy_ = 0;
  clear_has_mvy();
}
inline ::google::protobuf::int32 BlockInfo_MV::mvy() const {
  return mvy_;
}
inline void BlockInfo_MV::set_mvy(::google::protobuf::int32 value) {
  set_has_mvy();
  mvy_ = value;
}

// optional sint32 deltax = 3;
inline bool BlockInfo_MV::has_deltax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockInfo_MV::set_has_deltax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockInfo_MV::clear_has_deltax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockInfo_MV::clear_deltax() {
  deltax_ = 0;
  clear_has_deltax();
}
inline ::google::protobuf::int32 BlockInfo_MV::deltax() const {
  return deltax_;
}
inline void BlockInfo_MV::set_deltax(::google::protobuf::int32 value) {
  set_has_deltax();
  deltax_ = value;
}

// optional sint32 deltay = 4;
inline bool BlockInfo_MV::has_deltay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockInfo_MV::set_has_deltay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockInfo_MV::clear_has_deltay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockInfo_MV::clear_deltay() {
  deltay_ = 0;
  clear_has_deltay();
}
inline ::google::protobuf::int32 BlockInfo_MV::deltay() const {
  return deltay_;
}
inline void BlockInfo_MV::set_deltay(::google::protobuf::int32 value) {
  set_has_deltay();
  deltay_ = value;
}

// required int32 ref = 5;
inline bool BlockInfo_MV::has_ref() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockInfo_MV::set_has_ref() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockInfo_MV::clear_has_ref() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockInfo_MV::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 BlockInfo_MV::ref() const {
  return ref_;
}
inline void BlockInfo_MV::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// repeated .BlockInfo.MV.MVPredictor preds = 6;
inline int BlockInfo_MV::preds_size() const {
  return preds_.size();
}
inline void BlockInfo_MV::clear_preds() {
  preds_.Clear();
}
inline const ::BlockInfo_MV_MVPredictor& BlockInfo_MV::preds(int index) const {
  return preds_.Get(index);
}
inline ::BlockInfo_MV_MVPredictor* BlockInfo_MV::mutable_preds(int index) {
  return preds_.Mutable(index);
}
inline ::BlockInfo_MV_MVPredictor* BlockInfo_MV::add_preds() {
  return preds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV_MVPredictor >&
BlockInfo_MV::preds() const {
  return preds_;
}
inline ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV_MVPredictor >*
BlockInfo_MV::mutable_preds() {
  return &preds_;
}

// -------------------------------------------------------------------

// BlockInfo

// required .Point p = 1;
inline bool BlockInfo::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockInfo::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockInfo::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockInfo::clear_p() {
  if (p_ != NULL) p_->::Point::Clear();
  clear_has_p();
}
inline const ::Point& BlockInfo::p() const {
  return p_ != NULL ? *p_ : *default_instance_->p_;
}
inline ::Point* BlockInfo::mutable_p() {
  set_has_p();
  if (p_ == NULL) p_ = new ::Point;
  return p_;
}
inline ::Point* BlockInfo::release_p() {
  clear_has_p();
  ::Point* temp = p_;
  p_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_p(::Point* p) {
  delete p_;
  p_ = p;
  if (p) {
    set_has_p();
  } else {
    clear_has_p();
  }
}

// required int32 w = 2;
inline bool BlockInfo::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockInfo::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockInfo::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockInfo::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 BlockInfo::w() const {
  return w_;
}
inline void BlockInfo::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 3;
inline bool BlockInfo::has_h() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockInfo::set_has_h() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockInfo::clear_has_h() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockInfo::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 BlockInfo::h() const {
  return h_;
}
inline void BlockInfo::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// required int32 bools = 4;
inline bool BlockInfo::has_bools() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockInfo::set_has_bools() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockInfo::clear_has_bools() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockInfo::clear_bools() {
  bools_ = 0;
  clear_has_bools();
}
inline ::google::protobuf::int32 BlockInfo::bools() const {
  return bools_;
}
inline void BlockInfo::set_bools(::google::protobuf::int32 value) {
  set_has_bools();
  bools_ = value;
}

// required int32 bits = 5;
inline bool BlockInfo::has_bits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockInfo::set_has_bits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockInfo::clear_has_bits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockInfo::clear_bits() {
  bits_ = 0;
  clear_has_bits();
}
inline ::google::protobuf::int32 BlockInfo::bits() const {
  return bits_;
}
inline void BlockInfo::set_bits(::google::protobuf::int32 value) {
  set_has_bits();
  bits_ = value;
}

// required bool intra = 6;
inline bool BlockInfo::has_intra() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockInfo::set_has_intra() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockInfo::clear_has_intra() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockInfo::clear_intra() {
  intra_ = false;
  clear_has_intra();
}
inline bool BlockInfo::intra() const {
  return intra_;
}
inline void BlockInfo::set_intra(bool value) {
  set_has_intra();
  intra_ = value;
}

// optional int32 segment_id = 7;
inline bool BlockInfo::has_segment_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlockInfo::set_has_segment_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlockInfo::clear_has_segment_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlockInfo::clear_segment_id() {
  segment_id_ = 0;
  clear_has_segment_id();
}
inline ::google::protobuf::int32 BlockInfo::segment_id() const {
  return segment_id_;
}
inline void BlockInfo::set_segment_id(::google::protobuf::int32 value) {
  set_has_segment_id();
  segment_id_ = value;
}

// optional .BlockInfo.TxSize txSize = 8;
inline bool BlockInfo::has_txsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BlockInfo::set_has_txsize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BlockInfo::clear_has_txsize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BlockInfo::clear_txsize() {
  txsize_ = 0;
  clear_has_txsize();
}
inline ::BlockInfo_TxSize BlockInfo::txsize() const {
  return static_cast< ::BlockInfo_TxSize >(txsize_);
}
inline void BlockInfo::set_txsize(::BlockInfo_TxSize value) {
  assert(::BlockInfo_TxSize_IsValid(value));
  set_has_txsize();
  txsize_ = value;
}

// required bool skip = 9;
inline bool BlockInfo::has_skip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BlockInfo::set_has_skip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BlockInfo::clear_has_skip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BlockInfo::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool BlockInfo::skip() const {
  return skip_;
}
inline void BlockInfo::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
}

// repeated .BlockInfo.MV mv = 10;
inline int BlockInfo::mv_size() const {
  return mv_.size();
}
inline void BlockInfo::clear_mv() {
  mv_.Clear();
}
inline const ::BlockInfo_MV& BlockInfo::mv(int index) const {
  return mv_.Get(index);
}
inline ::BlockInfo_MV* BlockInfo::mutable_mv(int index) {
  return mv_.Mutable(index);
}
inline ::BlockInfo_MV* BlockInfo::add_mv() {
  return mv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV >&
BlockInfo::mv() const {
  return mv_;
}
inline ::google::protobuf::RepeatedPtrField< ::BlockInfo_MV >*
BlockInfo::mutable_mv() {
  return &mv_;
}

// optional .BlockInfo.SwitchableFilterType mcType = 11;
inline bool BlockInfo::has_mctype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BlockInfo::set_has_mctype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BlockInfo::clear_has_mctype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BlockInfo::clear_mctype() {
  mctype_ = 0;
  clear_has_mctype();
}
inline ::BlockInfo_SwitchableFilterType BlockInfo::mctype() const {
  return static_cast< ::BlockInfo_SwitchableFilterType >(mctype_);
}
inline void BlockInfo::set_mctype(::BlockInfo_SwitchableFilterType value) {
  assert(::BlockInfo_SwitchableFilterType_IsValid(value));
  set_has_mctype();
  mctype_ = value;
}

// optional .BlockInfo.IntraMode intraLumaMode = 12;
inline bool BlockInfo::has_intralumamode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BlockInfo::set_has_intralumamode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BlockInfo::clear_has_intralumamode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BlockInfo::clear_intralumamode() {
  intralumamode_ = 0;
  clear_has_intralumamode();
}
inline ::BlockInfo_IntraMode BlockInfo::intralumamode() const {
  return static_cast< ::BlockInfo_IntraMode >(intralumamode_);
}
inline void BlockInfo::set_intralumamode(::BlockInfo_IntraMode value) {
  assert(::BlockInfo_IntraMode_IsValid(value));
  set_has_intralumamode();
  intralumamode_ = value;
}

// optional .BlockInfo.IntraMode intraChromaMode = 13;
inline bool BlockInfo::has_intrachromamode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BlockInfo::set_has_intrachromamode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BlockInfo::clear_has_intrachromamode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BlockInfo::clear_intrachromamode() {
  intrachromamode_ = 0;
  clear_has_intrachromamode();
}
inline ::BlockInfo_IntraMode BlockInfo::intrachromamode() const {
  return static_cast< ::BlockInfo_IntraMode >(intrachromamode_);
}
inline void BlockInfo::set_intrachromamode(::BlockInfo_IntraMode value) {
  assert(::BlockInfo_IntraMode_IsValid(value));
  set_has_intrachromamode();
  intrachromamode_ = value;
}

// required int32 coeffBools = 14;
inline bool BlockInfo::has_coeffbools() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BlockInfo::set_has_coeffbools() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BlockInfo::clear_has_coeffbools() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BlockInfo::clear_coeffbools() {
  coeffbools_ = 0;
  clear_has_coeffbools();
}
inline ::google::protobuf::int32 BlockInfo::coeffbools() const {
  return coeffbools_;
}
inline void BlockInfo::set_coeffbools(::google::protobuf::int32 value) {
  set_has_coeffbools();
  coeffbools_ = value;
}

// required int32 coeffBits = 15;
inline bool BlockInfo::has_coeffbits() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BlockInfo::set_has_coeffbits() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BlockInfo::clear_has_coeffbits() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BlockInfo::clear_coeffbits() {
  coeffbits_ = 0;
  clear_has_coeffbits();
}
inline ::google::protobuf::int32 BlockInfo::coeffbits() const {
  return coeffbits_;
}
inline void BlockInfo::set_coeffbits(::google::protobuf::int32 value) {
  set_has_coeffbits();
  coeffbits_ = value;
}

// required int32 lumaDcScale = 16;
inline bool BlockInfo::has_lumadcscale() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BlockInfo::set_has_lumadcscale() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BlockInfo::clear_has_lumadcscale() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BlockInfo::clear_lumadcscale() {
  lumadcscale_ = 0;
  clear_has_lumadcscale();
}
inline ::google::protobuf::int32 BlockInfo::lumadcscale() const {
  return lumadcscale_;
}
inline void BlockInfo::set_lumadcscale(::google::protobuf::int32 value) {
  set_has_lumadcscale();
  lumadcscale_ = value;
}

// required int32 lumaAcScale = 17;
inline bool BlockInfo::has_lumaacscale() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BlockInfo::set_has_lumaacscale() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BlockInfo::clear_has_lumaacscale() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BlockInfo::clear_lumaacscale() {
  lumaacscale_ = 0;
  clear_has_lumaacscale();
}
inline ::google::protobuf::int32 BlockInfo::lumaacscale() const {
  return lumaacscale_;
}
inline void BlockInfo::set_lumaacscale(::google::protobuf::int32 value) {
  set_has_lumaacscale();
  lumaacscale_ = value;
}

// required int32 chromaDcScale = 18;
inline bool BlockInfo::has_chromadcscale() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BlockInfo::set_has_chromadcscale() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BlockInfo::clear_has_chromadcscale() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BlockInfo::clear_chromadcscale() {
  chromadcscale_ = 0;
  clear_has_chromadcscale();
}
inline ::google::protobuf::int32 BlockInfo::chromadcscale() const {
  return chromadcscale_;
}
inline void BlockInfo::set_chromadcscale(::google::protobuf::int32 value) {
  set_has_chromadcscale();
  chromadcscale_ = value;
}

// required int32 chromaAcScale = 19;
inline bool BlockInfo::has_chromaacscale() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BlockInfo::set_has_chromaacscale() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BlockInfo::clear_has_chromaacscale() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BlockInfo::clear_chromaacscale() {
  chromaacscale_ = 0;
  clear_has_chromaacscale();
}
inline ::google::protobuf::int32 BlockInfo::chromaacscale() const {
  return chromaacscale_;
}
inline void BlockInfo::set_chromaacscale(::google::protobuf::int32 value) {
  set_has_chromaacscale();
  chromaacscale_ = value;
}

// required int32 bitPos = 20;
inline bool BlockInfo::has_bitpos() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BlockInfo::set_has_bitpos() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BlockInfo::clear_has_bitpos() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BlockInfo::clear_bitpos() {
  bitpos_ = 0;
  clear_has_bitpos();
}
inline ::google::protobuf::int32 BlockInfo::bitpos() const {
  return bitpos_;
}
inline void BlockInfo::set_bitpos(::google::protobuf::int32 value) {
  set_has_bitpos();
  bitpos_ = value;
}

// required int32 syntaxStart = 21;
inline bool BlockInfo::has_syntaxstart() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BlockInfo::set_has_syntaxstart() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BlockInfo::clear_has_syntaxstart() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BlockInfo::clear_syntaxstart() {
  syntaxstart_ = 0;
  clear_has_syntaxstart();
}
inline ::google::protobuf::int32 BlockInfo::syntaxstart() const {
  return syntaxstart_;
}
inline void BlockInfo::set_syntaxstart(::google::protobuf::int32 value) {
  set_has_syntaxstart();
  syntaxstart_ = value;
}

// -------------------------------------------------------------------

// Coeffs

// repeated sint32 coeffs = 1;
inline int Coeffs::coeffs_size() const {
  return coeffs_.size();
}
inline void Coeffs::clear_coeffs() {
  coeffs_.Clear();
}
inline ::google::protobuf::int32 Coeffs::coeffs(int index) const {
  return coeffs_.Get(index);
}
inline void Coeffs::set_coeffs(int index, ::google::protobuf::int32 value) {
  coeffs_.Set(index, value);
}
inline void Coeffs::add_coeffs(::google::protobuf::int32 value) {
  coeffs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Coeffs::coeffs() const {
  return coeffs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Coeffs::mutable_coeffs() {
  return &coeffs_;
}

// -------------------------------------------------------------------

// SuperblockInfo

// required int32 sbCol = 1;
inline bool SuperblockInfo::has_sbcol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuperblockInfo::set_has_sbcol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuperblockInfo::clear_has_sbcol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuperblockInfo::clear_sbcol() {
  sbcol_ = 0;
  clear_has_sbcol();
}
inline ::google::protobuf::int32 SuperblockInfo::sbcol() const {
  return sbcol_;
}
inline void SuperblockInfo::set_sbcol(::google::protobuf::int32 value) {
  set_has_sbcol();
  sbcol_ = value;
}

// required int32 sbRow = 2;
inline bool SuperblockInfo::has_sbrow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuperblockInfo::set_has_sbrow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuperblockInfo::clear_has_sbrow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuperblockInfo::clear_sbrow() {
  sbrow_ = 0;
  clear_has_sbrow();
}
inline ::google::protobuf::int32 SuperblockInfo::sbrow() const {
  return sbrow_;
}
inline void SuperblockInfo::set_sbrow(::google::protobuf::int32 value) {
  set_has_sbrow();
  sbrow_ = value;
}

// repeated .BlockInfo blocks = 3;
inline int SuperblockInfo::blocks_size() const {
  return blocks_.size();
}
inline void SuperblockInfo::clear_blocks() {
  blocks_.Clear();
}
inline const ::BlockInfo& SuperblockInfo::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::BlockInfo* SuperblockInfo::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::BlockInfo* SuperblockInfo::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BlockInfo >&
SuperblockInfo::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::BlockInfo >*
SuperblockInfo::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// SuperblockRegion

// required int32 sbCol = 1;
inline bool SuperblockRegion::has_sbcol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuperblockRegion::set_has_sbcol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuperblockRegion::clear_has_sbcol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuperblockRegion::clear_sbcol() {
  sbcol_ = 0;
  clear_has_sbcol();
}
inline ::google::protobuf::int32 SuperblockRegion::sbcol() const {
  return sbcol_;
}
inline void SuperblockRegion::set_sbcol(::google::protobuf::int32 value) {
  set_has_sbcol();
  sbcol_ = value;
}

// required int32 sbRow = 2;
inline bool SuperblockRegion::has_sbrow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuperblockRegion::set_has_sbrow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuperblockRegion::clear_has_sbrow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuperblockRegion::clear_sbrow() {
  sbrow_ = 0;
  clear_has_sbrow();
}
inline ::google::protobuf::int32 SuperblockRegion::sbrow() const {
  return sbrow_;
}
inline void SuperblockRegion::set_sbrow(::google::protobuf::int32 value) {
  set_has_sbrow();
  sbrow_ = value;
}

// required int32 sbCols = 3;
inline bool SuperblockRegion::has_sbcols() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuperblockRegion::set_has_sbcols() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuperblockRegion::clear_has_sbcols() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuperblockRegion::clear_sbcols() {
  sbcols_ = 0;
  clear_has_sbcols();
}
inline ::google::protobuf::int32 SuperblockRegion::sbcols() const {
  return sbcols_;
}
inline void SuperblockRegion::set_sbcols(::google::protobuf::int32 value) {
  set_has_sbcols();
  sbcols_ = value;
}

// required int32 sbRows = 4;
inline bool SuperblockRegion::has_sbrows() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SuperblockRegion::set_has_sbrows() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SuperblockRegion::clear_has_sbrows() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SuperblockRegion::clear_sbrows() {
  sbrows_ = 0;
  clear_has_sbrows();
}
inline ::google::protobuf::int32 SuperblockRegion::sbrows() const {
  return sbrows_;
}
inline void SuperblockRegion::set_sbrows(::google::protobuf::int32 value) {
  set_has_sbrows();
  sbrows_ = value;
}

// repeated .SuperblockInfo superblocks = 5;
inline int SuperblockRegion::superblocks_size() const {
  return superblocks_.size();
}
inline void SuperblockRegion::clear_superblocks() {
  superblocks_.Clear();
}
inline const ::SuperblockInfo& SuperblockRegion::superblocks(int index) const {
  return superblocks_.Get(index);
}
inline ::SuperblockInfo* SuperblockRegion::mutable_superblocks(int index) {
  return superblocks_.Mutable(index);
}
inline ::SuperblockInfo* SuperblockRegion::add_superblocks() {
  return superblocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SuperblockInfo >&
SuperblockRegion::superblocks() const {
  return superblocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::SuperblockInfo >*
SuperblockRegion::mutable_superblocks() {
  return &superblocks_;
}

// -------------------------------------------------------------------

// RawBytes

// required int32 pos = 1;
inline bool RawBytes::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawBytes::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawBytes::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawBytes::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 RawBytes::pos() const {
  return pos_;
}
inline void RawBytes::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// required bytes data = 2;
inline bool RawBytes::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawBytes::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawBytes::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawBytes::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RawBytes::data() const {
  return *data_;
}
inline void RawBytes::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RawBytes::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RawBytes::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RawBytes::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* RawBytes::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RawBytes::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoopFilterEdge_FilterType>() {
  return ::LoopFilterEdge_FilterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BlockInfo_TxSize>() {
  return ::BlockInfo_TxSize_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BlockInfo_SwitchableFilterType>() {
  return ::BlockInfo_SwitchableFilterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BlockInfo_IntraMode>() {
  return ::BlockInfo_IntraMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vp9bat_2eproto__INCLUDED
