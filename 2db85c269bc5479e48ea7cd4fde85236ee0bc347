{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1b642f81_52106e8a",
        "filename": "vpx_dsp/arm/sad4d_neon.c",
        "patchSetId": 1
      },
      "lineNbr": 240,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-10T18:36:43Z",
      "side": 1,
      "message": "just out of curiosity, the docs say A32/A64 [1]. Am I misunderstanding that or is it or this check incorrect? For media applications we haven\u0027t run into aarch32, where is that commonly being used?\n\n[1] https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search\u003dudot",
      "range": {
        "startLine": 240,
        "startChar": 12,
        "endLine": 240,
        "endChar": 23
      },
      "revId": "2db85c269bc5479e48ea7cd4fde85236ee0bc347",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c768e9e8_d57eef9e",
        "filename": "vpx_dsp/arm/sad4d_neon.c",
        "patchSetId": 1
      },
      "lineNbr": 240,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2021-05-10T20:41:29Z",
      "side": 1,
      "message": "A32 and A64 are instructions sets while AArch32 and AArch64 are processor execution modes. I.e. an Armv8 processor executing in AArch64 (64-bit) mode would be executing A64 instructions and vice versa for AArch32 and A32 - so one necessarily implies the other.\n\nBefore Armv8, there was only 32-bit \"Arm\" (Armv7 is roughly equivalent to AArch32), hence the 32-bit toolchain triples in use today are e.g. arm-linux-gnueabi. If we had been consistent (and had the benefit of hindsight) we probably would have had aarch32-linux-gnu... and aarch64-linux-gnu. The compiler-defined macros to determine the target are \"__arm__\" and \"__aarch64__\".\n\nTo add to the confusion of modes and instructions sets, some people refer to \"64-bit Arm\" as \"arm64\" - which we don\u0027t officially recognize.",
      "parentUuid": "1b642f81_52106e8a",
      "range": {
        "startLine": 240,
        "startChar": 12,
        "endLine": 240,
        "endChar": 23
      },
      "revId": "2db85c269bc5479e48ea7cd4fde85236ee0bc347",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "44c1b2ed_603d886d",
        "filename": "vpx_dsp/arm/sad4d_neon.c",
        "patchSetId": 1
      },
      "lineNbr": 240,
      "author": {
        "id": 1002219
      },
      "writtenOn": "2021-05-10T23:21:49Z",
      "side": 1,
      "message": "\u003e A32 and A64 are instructions sets while AArch32 and AArch64 are processor execution modes. I.e. an Armv8 processor executing in AArch64 (64-bit) mode would be executing A64 instructions and vice versa for AArch32 and A32 - so one necessarily implies the other.\n\u003e \n\u003e Before Armv8, there was only 32-bit \"Arm\" (Armv7 is roughly equivalent to AArch32), hence the 32-bit toolchain triples in use today are e.g. arm-linux-gnueabi. If we had been consistent (and had the benefit of hindsight) we probably would have had aarch32-linux-gnu... and aarch64-linux-gnu. The compiler-defined macros to determine the target are \"__arm__\" and \"__aarch64__\".\n\u003e \n\nThanks for clarifying. I was thinking of __arm__ as only armv7 and prior.\n\n\u003e To add to the confusion of modes and instructions sets, some people refer to \"64-bit Arm\" as \"arm64\" - which we don\u0027t officially recognize.\n\nYes, we do that in this project as a matter of fact.",
      "parentUuid": "c768e9e8_d57eef9e",
      "range": {
        "startLine": 240,
        "startChar": 12,
        "endLine": 240,
        "endChar": 23
      },
      "revId": "2db85c269bc5479e48ea7cd4fde85236ee0bc347",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}