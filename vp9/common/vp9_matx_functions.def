/*  vim:filetype=c
 *
 *  Copyright (c) 2016 The WebM project authors. All Rights Reserved.
 *
 *  Use of this source code is governed  by a BSD-style license that can be
 *  found in the LICENSE file in the root of the source tree. An additional
 *  intellectual property  rights grant can  be found in the  file PATENTS.
 *  All contributing  project authors may be  found in the AUTHORS  file in
 *  the root of the source tree.
 */

#ifdef MATX_SUFFIX

#include "string.h"
#include "stdio.h"
#include "assert.h"

#include "vp9/common/vp9_matx_enums.h"
#include "vp9/common/vp9_matx.h"

void MATX_DEFINE_FUNC(zerofill)(struct T_MATX_STRUCT* const image) {
  memset(image->data, 0, image->rows*image->stride*sizeof(T_MATX_ELEMTYPE));
}

void MATX_DEFINE_FUNC(set_to)(struct T_MATX_STRUCT* const image,
                              T_MATX_ELEMTYPE value) {
  int i, j;

  for (i = 0; i < image->rows; ++i) {
    T_MATX_ELEMTYPE *row_data = &image->data[i*image->stride];

    for (j = 0; j < image->cols*image->cn; ++j)
       row_data[j] = value;
  }
}

void MATX_DEFINE_FUNC(copy_to)(const struct T_MATX_STRUCT* const src,
                               struct T_MATX_STRUCT* const dst) {
  int i;

  if (dst->data == src->data)
    return;

  MATX_APPLY_FUNC(affirm)(dst, src->rows, src->cols, src->stride, src->cn);

  for (i = 0; i < src->rows; ++i) {
    const T_MATX_ELEMTYPE *copy_from = src->data + i*src->stride;
    T_MATX_ELEMTYPE *copy_to = dst->data + i*dst->stride;

    memcpy(copy_to, copy_from, src->cols*sizeof(T_MATX_ELEMTYPE));
  }
}

void MATX_DEFINE_FUNC(imwrite)(const struct T_MATX_STRUCT* const image,
                               const char* const filename, int max_value) {
  int i, j;

  const char* format_strings[] = {
      "%hhu ",  // TYPE_8U
      "%hhd ",  // TYPE_8S
       "%hu ",  // TYPE_16U
       "%hd ",  // TYPE_16S
        "%u ",  // TYPE_32U
        "%d ",  // TYPE_32S
      "%.4f ",  // TYPE_32F
      "%.4f "   // TYPE_64F
  };

  FILE *const image_file = fopen(filename, "wt");
  const char* const format_string = format_strings[image->typeid];

  assert(image->rows > 0 && image->cols > 0);
  assert(image->data != NULL);
  assert(image->cn == 1 || image->cn == 3);

  assert(image->typeid != TYPE_32F /*type not supported*/);
  assert(image->typeid != TYPE_64F /*type not supported*/);

  if (max_value < 0)
    max_value = 255;

  fprintf(image_file, "P%d\n", image->cn/2 + 2);
  fprintf(image_file, "%d %d %d", image->cols, image->rows, max_value);

  for (i = 0; i < image->rows; ++i) {
    const T_MATX_ELEMTYPE *row_data = &image->data[i*image->stride];

    fprintf(image_file, "\n");
    for (j = 0; j < image->cols*image->cn; ++j)
      fprintf(image_file, format_string, row_data[j]);
  }

  fclose(image_file); // ---------------------------------------- //
}


#undef MATX_SUFFIX
#endif
