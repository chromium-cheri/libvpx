{
  "comments": [
    {
      "key": {
        "uuid": "534a1d43_a6065e56",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1117029
      },
      "writtenOn": "2015-07-07T19:00:13Z",
      "side": 1,
      "message": "i wonder why hbuf is int, given that it accumulates unsigned values.",
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "736d61b3_1f2da6cd",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1001914
      },
      "writtenOn": "2015-07-07T19:31:55Z",
      "side": 1,
      "message": "It uses up to 14 bits. So both uint16_t and int16_t are fine. The result is then involved in subtraction, which requires int type. The original plan was to avoid converting uint to int in the next comparison stage.",
      "parentUuid": "534a1d43_a6065e56",
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f356b1ec_63faaa3b",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 1117029
      },
      "writtenOn": "2015-07-07T19:00:13Z",
      "side": 1,
      "message": "the goal of this is to convert 64 -\u003e 5, 32 -\u003e 4, 16 -\u003e 3. skip the negation, the correct instruction exists for neon. vshrq_u16. unless there\u0027s some side effect where using the negative value causes a signed shift? should convert/reinterpret first in that case.",
      "range": {
        "startLine": 56,
        "startChar": 50,
        "endLine": 56,
        "endChar": 51
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "534a1d43_06372a0c",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 1002054
      },
      "writtenOn": "2015-07-07T19:18:37Z",
      "side": 1,
      "message": "I couldn\u0027t find vshrq_u16. Still can\u0027t :)",
      "parentUuid": "f356b1ec_63faaa3b",
      "range": {
        "startLine": 56,
        "startChar": 50,
        "endLine": 56,
        "endChar": 51
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f356b1ec_63b1ca7b",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 1117029
      },
      "writtenOn": "2015-07-07T19:26:23Z",
      "side": 1,
      "message": "oh woops. llvm has it defined in their targets, weird, but it\u0027s not an intrinsic or an actual instruction. that\u0027s awkward.",
      "parentUuid": "534a1d43_06372a0c",
      "range": {
        "startLine": 56,
        "startChar": 50,
        "endLine": 56,
        "endChar": 51
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f80dae2c_bd5627a0",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 96,
      "author": {
        "id": 1117029
      },
      "writtenOn": "2015-07-07T19:00:13Z",
      "side": 1,
      "message": "the sse2 breaks this out with an if statement because, like neon, the instruction that does this only takes a constant, not a variable. vshrq_n_u16. not sure whether calculating and duping the value is better or the if statements.",
      "range": {
        "startLine": 96,
        "startChar": 25,
        "endLine": 96,
        "endChar": 35
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f356b1ec_63562aa2",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 96,
      "author": {
        "id": 1002054
      },
      "writtenOn": "2015-07-07T19:18:37Z",
      "side": 1,
      "message": "I had the if statements with the shift by constant at first, but the generated code added 1-2 branches.",
      "parentUuid": "f80dae2c_bd5627a0",
      "range": {
        "startLine": 96,
        "startChar": 25,
        "endLine": 96,
        "endChar": 35
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f356b1ec_a399f200",
        "filename": "vp9/encoder/arm/neon/vp9_avg_neon.c",
        "patchSetId": 5
      },
      "lineNbr": 96,
      "author": {
        "id": 1117029
      },
      "writtenOn": "2015-07-07T19:26:23Z",
      "side": 1,
      "message": "i guess the hardcore alternative would be 16, 32, 64 specific functions. it\u0027d allow the compiler some more leeway with the larger values (i don\u0027t think it\u0027ll even unroll this twice, even though all the possibilities allow it)",
      "parentUuid": "f356b1ec_63562aa2",
      "range": {
        "startLine": 96,
        "startChar": 25,
        "endLine": 96,
        "endChar": 35
      },
      "revId": "944ad6cac9391fc84c189c31a950e8e88ee62205",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}